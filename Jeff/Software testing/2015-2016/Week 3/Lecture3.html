<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0070)http://homepages.cwi.nl/~jve/courses/15/testing/lectures/Lecture3.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="Content-Style-Type" content="text/css">
  <meta name="generator" content="pandoc">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="./Lecture3_files/buttondown.css" type="text/css">
  <script src="./Lecture3_files/MathJax.js" type="text/javascript"></script>
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><style type="text/css">.MathJax_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}
.MathJax .merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MathJax .MJX-monospace {font-family: monospace}
.MathJax .MJX-sans-serif {font-family: sans-serif}
#MathJax_Tooltip {background-color: InfoBackground; color: InfoText; border: 1px solid black; box-shadow: 2px 2px 5px #AAAAAA; -webkit-box-shadow: 2px 2px 5px #AAAAAA; -moz-box-shadow: 2px 2px 5px #AAAAAA; -khtml-box-shadow: 2px 2px 5px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true'); padding: 3px 4px; z-index: 401; position: absolute; left: 0; top: 0; width: auto; height: auto; display: none}
.MathJax {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}
.MathJax:focus, body :focus .MathJax {display: inline-table}
.MathJax img, .MathJax nobr, .MathJax a {border: 0; padding: 0; margin: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; vertical-align: 0; line-height: normal; text-decoration: none}
img.MathJax_strut {border: 0!important; padding: 0!important; margin: 0!important; vertical-align: 0!important}
.MathJax span {display: inline; position: static; border: 0; padding: 0; margin: 0; vertical-align: 0; line-height: normal; text-decoration: none}
.MathJax nobr {white-space: nowrap!important}
.MathJax img {display: inline!important; float: none!important}
.MathJax * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}
.MathJax_Processing {visibility: hidden; position: fixed; width: 0; height: 0; overflow: hidden}
.MathJax_Processed {display: none!important}
.MathJax_ExBox {display: block!important; overflow: hidden; width: 1px; height: 60ex; min-height: 0; max-height: none}
.MathJax .MathJax_EmBox {display: block!important; overflow: hidden; width: 1px; height: 60em; min-height: 0; max-height: none}
.MathJax .MathJax_HitBox {cursor: text; background: white; opacity: 0; filter: alpha(opacity=0)}
.MathJax .MathJax_HitBox * {filter: none; opacity: 1; background: transparent}
#MathJax_Tooltip * {filter: none; opacity: 1; background: transparent}
@font-face {font-family: MathJax_Main; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Main-bold; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Main-italic; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Math-italic; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Caligraphic; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Size1; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Size2; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Size3; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Size4; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf?rev=2.6.0') format('opentype')}
.MathJax .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><style type="text/css">@font-face {font-family: MathJax_AMS; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_AMS-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_AMS-Regular.otf?rev=2.6.0') format('opentype')}
</style></head>
<body><div style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="display: none;"></div>
<h1 id="lecture-3-more-on-hoare-logic-and-propositional-logic">Lecture 3: More on Hoare Logic and Propositional Logic</h1>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Lecture3</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">where</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.List</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Char</span></code></pre></div>
<p><strong>Function Composition, With Flipped Order</strong></p>
<p>With normal order:</p>
<pre><code>(.) :: (a -&gt; b) -&gt; (c -&gt; a) -&gt; (c -&gt; b)
f . g = \ x -&gt; f (g x)</code></pre>
<p>Flip the order:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">infixl</span> <span class="dv">2</span> <span class="fu">#</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; (#) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)
<span class="ot">&gt;</span> (<span class="fu">#</span>) <span class="fu">=</span> flip (<span class="fu">.</span>)</code></pre></div>
<p>Read <code>f # g</code> as <em><code>f</code> followed by <code>g</code></em>.</p>
<p>Restatement of the composition rule</p>
<p>From</p>
<pre><code>{ p } f { q }     and    { q } g { r }</code></pre>
<p>conclude:</p>
<pre><code>{ p } f # g { r }</code></pre>
<p><strong>Function Application, with Flipped Order</strong></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">infixl</span> <span class="dv">1</span> <span class="fu">$$</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; ($$) ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> (<span class="fu">$$</span>) <span class="fu">=</span> flip (<span class="fu">$</span>)</code></pre></div>
<p>Example:</p>
<pre><code>*Lecture2&gt; 5 $$ succ
6</code></pre>
<p><strong>Review question</strong>: can you work out the types and the definitions of <code>flip</code> and <code>$</code>?</p>
<p><strong>Review question</strong>: why is <code>$</code> a useful operation?</p>
<p><strong>No Assignment in Pure Functional Programming</strong></p>
<p>Question: what is the difference between <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;&amp;#x03BB;&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x21A6;&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-1" role="math" style="width: 5.282em; display: inline-block;"><span style="display: inline-block; position: relative; width: 5.1em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.277em 1005.04em 2.37em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">λ</span><span class="mi" id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-5" style="font-family: MathJax_Main; padding-left: 0.306em;">↦</span><span class="mi" id="MathJax-Span-6" style="font-family: MathJax_Math-italic; padding-left: 0.306em;">x</span><span class="mo" id="MathJax-Span-7" style="font-family: MathJax_Main; padding-left: 0.246em;">+</span><span class="mn" id="MathJax-Span-8" style="font-family: MathJax_Main; padding-left: 0.246em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.941em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>λ</mi><mi>x</mi><mo stretchy="false">↦</mo><mi>x</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-1">\lambda x \mapsto x+1</script></span> and <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;:=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-9" role="math" style="width: 4.797em; display: inline-block;"><span style="display: inline-block; position: relative; width: 4.615em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.277em 1004.55em 2.37em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-10"><span class="mi" id="MathJax-Span-11" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-12" style="font-family: MathJax_Main; padding-left: 0.306em;">:<span style="font-family: MathJax_Main;">=</span></span><span class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math-italic; padding-left: 0.306em;">x</span><span class="mo" id="MathJax-Span-14" style="font-family: MathJax_Main; padding-left: 0.246em;">+</span><span class="mn" id="MathJax-Span-15" style="font-family: MathJax_Main; padding-left: 0.246em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.878em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>:=</mo><mi>x</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2">x := x+1</script></span>?</p>
<p>Answer: for one thing, the types are different:</p>
<p><span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;&amp;#x03BB;&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x21A6;&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-16" role="math" style="width: 5.282em; display: inline-block;"><span style="display: inline-block; position: relative; width: 5.1em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.277em 1005.04em 2.37em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-17"><span class="mi" id="MathJax-Span-18" style="font-family: MathJax_Math-italic;">λ</span><span class="mi" id="MathJax-Span-19" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-20" style="font-family: MathJax_Main; padding-left: 0.306em;">↦</span><span class="mi" id="MathJax-Span-21" style="font-family: MathJax_Math-italic; padding-left: 0.306em;">x</span><span class="mo" id="MathJax-Span-22" style="font-family: MathJax_Main; padding-left: 0.246em;">+</span><span class="mn" id="MathJax-Span-23" style="font-family: MathJax_Main; padding-left: 0.246em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.941em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>λ</mi><mi>x</mi><mo stretchy="false">↦</mo><mi>x</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3">\lambda x \mapsto x+1</script></span> is a function.</p>
<p><span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;:=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-24" role="math" style="width: 4.797em; display: inline-block;"><span style="display: inline-block; position: relative; width: 4.615em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.277em 1004.55em 2.37em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-25"><span class="mi" id="MathJax-Span-26" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-27" style="font-family: MathJax_Main; padding-left: 0.306em;">:<span style="font-family: MathJax_Main;">=</span></span><span class="mi" id="MathJax-Span-28" style="font-family: MathJax_Math-italic; padding-left: 0.306em;">x</span><span class="mo" id="MathJax-Span-29" style="font-family: MathJax_Main; padding-left: 0.246em;">+</span><span class="mn" id="MathJax-Span-30" style="font-family: MathJax_Main; padding-left: 0.246em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.878em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>:=</mo><mi>x</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4">x := x+1</script></span> is interpreted in the context of a current memory allocation (an <em>environment</em>), with <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-5-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-31" role="math" style="width: 0.671em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.61em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.338em 1000.55em 2.127em -999.997em); top: -1.939em; left: 0.003em;"><span class="mrow" id="MathJax-Span-32"><span class="mi" id="MathJax-Span-33" style="font-family: MathJax_Math-italic;">x</span></span><span style="display: inline-block; width: 0px; height: 1.945em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.566em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-5">x</script></span> naming a memory cell.</p>
<p><span class="math display"><span class="MathJax_Preview" style="color: inherit;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-6-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mtable columnalign=&quot;center center center center center&quot; rowspacing=&quot;4pt&quot; columnspacing=&quot;1em&quot;&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mo&gt;&amp;#x22EF;&lt;/mo&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mo&gt;&amp;#x22EF;&lt;/mo&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mo&gt;&amp;#x22EF;&lt;/mo&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mi&gt;&amp;#x25FB;&lt;/mi&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mi&gt;&amp;#x25FB;&lt;/mi&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mi&gt;&amp;#x25FB;&lt;/mi&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mo&gt;&amp;#x22EF;&lt;/mo&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-34" role="math" style="width: 9.408em; display: inline-block;"><span style="display: inline-block; position: relative; width: 9.105em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(0.549em 1008.86em 3.34em -999.997em); top: -2.181em; left: 0.003em;"><span class="mrow" id="MathJax-Span-35"><span class="mtable" id="MathJax-Span-36" style="padding-right: 0.185em; padding-left: 0.185em;"><span style="display: inline-block; position: relative; width: 8.68em; height: 0px;"><span style="position: absolute; clip: rect(2.855em 1001.1em 4.736em -999.997em); top: -4.002em; left: 0.003em;"><span style="display: inline-block; position: relative; width: 1.156em; height: 0px;"><span style="position: absolute; clip: rect(3.522em 1001.1em 4.008em -999.997em); top: -4.669em; left: 50%; margin-left: -0.604em;"><span class="mtd" id="MathJax-Span-37"><span class="mrow" id="MathJax-Span-38"><span class="mo" id="MathJax-Span-39" style="font-family: MathJax_Main;">⋯</span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span><span style="position: absolute; clip: rect(3.522em 1001.1em 4.008em -999.997em); top: -3.274em; left: 50%; margin-left: -0.604em;"><span class="mtd" id="MathJax-Span-52"><span class="mrow" id="MathJax-Span-53"><span class="mo" id="MathJax-Span-54" style="font-family: MathJax_Main;">⋯</span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span><span style="position: absolute; clip: rect(2.734em 1000.73em 4.918em -999.997em); top: -4.002em; left: 2.187em;"><span style="display: inline-block; position: relative; width: 0.792em; height: 0px;"><span style="position: absolute; clip: rect(3.401em 1000.55em 4.19em -999.997em); top: -4.669em; left: 50%; margin-left: -0.3em;"><span class="mtd" id="MathJax-Span-40"><span class="mrow" id="MathJax-Span-41"><span class="mi" id="MathJax-Span-42" style="font-family: MathJax_Math-italic;">x</span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span><span style="position: absolute; clip: rect(3.158em 1000.73em 4.19em -999.997em); top: -3.274em; left: 50%; margin-left: -0.361em;"><span class="mtd" id="MathJax-Span-55"><span class="mrow" id="MathJax-Span-56"><span class="mi" id="MathJax-Span-57" style="font-family: MathJax_AMS;">□</span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span><span style="position: absolute; clip: rect(2.734em 1000.73em 4.918em -999.997em); top: -4.002em; left: 3.947em;"><span style="display: inline-block; position: relative; width: 0.792em; height: 0px;"><span style="position: absolute; clip: rect(3.401em 1000.49em 4.372em -999.997em); top: -4.669em; left: 50%; margin-left: -0.24em;"><span class="mtd" id="MathJax-Span-43"><span class="mrow" id="MathJax-Span-44"><span class="mi" id="MathJax-Span-45" style="font-family: MathJax_Math-italic;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span><span style="position: absolute; clip: rect(3.158em 1000.73em 4.19em -999.997em); top: -3.274em; left: 50%; margin-left: -0.361em;"><span class="mtd" id="MathJax-Span-58"><span class="mrow" id="MathJax-Span-59"><span class="mi" id="MathJax-Span-60" style="font-family: MathJax_AMS;">□</span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span><span style="position: absolute; clip: rect(2.734em 1000.73em 4.918em -999.997em); top: -4.002em; left: 5.707em;"><span style="display: inline-block; position: relative; width: 0.792em; height: 0px;"><span style="position: absolute; clip: rect(3.401em 1000.49em 4.19em -999.997em); top: -4.669em; left: 50%; margin-left: -0.24em;"><span class="mtd" id="MathJax-Span-46"><span class="mrow" id="MathJax-Span-47"><span class="mi" id="MathJax-Span-48" style="font-family: MathJax_Math-italic;">z<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span><span style="position: absolute; clip: rect(3.158em 1000.73em 4.19em -999.997em); top: -3.274em; left: 50%; margin-left: -0.361em;"><span class="mtd" id="MathJax-Span-61"><span class="mrow" id="MathJax-Span-62"><span class="mi" id="MathJax-Span-63" style="font-family: MathJax_AMS;">□</span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span><span style="position: absolute; clip: rect(2.855em 1001.1em 4.736em -999.997em); top: -4.002em; left: 7.527em;"><span style="display: inline-block; position: relative; width: 1.156em; height: 0px;"><span style="position: absolute; clip: rect(3.522em 1001.1em 4.008em -999.997em); top: -4.669em; left: 50%; margin-left: -0.604em;"><span class="mtd" id="MathJax-Span-49"><span class="mrow" id="MathJax-Span-50"><span class="mo" id="MathJax-Span-51" style="font-family: MathJax_Main;">⋯</span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span><span style="position: absolute; clip: rect(3.522em 1001.1em 4.008em -999.997em); top: -3.274em; left: 50%; margin-left: -0.604em;"><span class="mtd" id="MathJax-Span-64"><span class="mrow" id="MathJax-Span-65"><span class="mo" id="MathJax-Span-66" style="font-family: MathJax_Main;">⋯</span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.187em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -1.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 2.628em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable columnalign="center center center center center" rowspacing="4pt" columnspacing="1em"><mtr><mtd><mo>⋯</mo></mtd><mtd><mi>x</mi></mtd><mtd><mi>y</mi></mtd><mtd><mi>z</mi></mtd><mtd><mo>⋯</mo></mtd></mtr><mtr><mtd><mo>⋯</mo></mtd><mtd><mi>◻</mi></mtd><mtd><mi>◻</mi></mtd><mtd><mi>◻</mi></mtd><mtd><mo>⋯</mo></mtd></mtr></mtable></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-6">
\begin{array}{ccccc}
  \cdots & x & y & z & \cdots \\
  \cdots & \Box &  \Box & \Box & \cdots 
\end{array}
</script></span></p>
<p>Such an environment (for integers, say), is a function of type <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-7-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x2192;&lt;/mo&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-67" role="math" style="width: 4.008em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.887em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.277em 1003.83em 2.309em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-68"><span class="mi" id="MathJax-Span-69" style="font-family: MathJax_Math-italic;">V<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.185em;"></span></span><span class="mo" id="MathJax-Span-70" style="font-family: MathJax_Main; padding-left: 0.306em;">→</span><span class="mi" id="MathJax-Span-71" style="font-family: MathJax_Math-italic; padding-left: 0.306em;">I<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.064em;"></span></span><span class="mi" id="MathJax-Span-72" style="font-family: MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-73" style="font-family: MathJax_Math-italic;">t</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.878em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>V</mi><mo stretchy="false">→</mo><mi>I</mi><mi>n</mi><mi>t</mi></math></span></span><script type="math/tex" id="MathJax-Element-7">V \to Int</script></span>, where <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-8-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-74" role="math" style="width: 0.853em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.792em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.095em 1000.79em 2.127em -999.997em); top: -1.939em; left: 0.003em;"><span class="mrow" id="MathJax-Span-75"><span class="mi" id="MathJax-Span-76" style="font-family: MathJax_Math-italic;">V<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.185em;"></span></span></span><span style="display: inline-block; width: 0px; height: 1.945em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.878em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>V</mi></math></span></span><script type="math/tex" id="MathJax-Element-8">V</script></span> is a set of variables.</p>
<p><strong>Assignment as Update</strong></p>
<p>Assignment can be viewed as updating the definition of a function.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; update ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a,b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> update f (x,y) <span class="fu">=</span> \ z <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="fu">==</span> z <span class="kw">then</span> y <span class="kw">else</span> f z </code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; updates ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [(a,b)] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> updates <span class="fu">=</span> foldl update </code></pre></div>
<p>The command <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-9-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;:=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-77" role="math" style="width: 4.797em; display: inline-block;"><span style="display: inline-block; position: relative; width: 4.615em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.277em 1004.55em 2.37em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-78"><span class="mi" id="MathJax-Span-79" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-80" style="font-family: MathJax_Main; padding-left: 0.306em;">:<span style="font-family: MathJax_Main;">=</span></span><span class="mi" id="MathJax-Span-81" style="font-family: MathJax_Math-italic; padding-left: 0.306em;">x</span><span class="mo" id="MathJax-Span-82" style="font-family: MathJax_Main; padding-left: 0.246em;">+</span><span class="mn" id="MathJax-Span-83" style="font-family: MathJax_Main; padding-left: 0.246em;">1</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.878em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>:=</mo><mi>x</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-9">x := x+1</script></span> can be viewed as an <em>update operation</em> on an environment.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Var</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Var</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></code></pre></div>
<p>To implement variable assignment we need a datatype for expressions, for the assign command assigns an expression to a variable.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">I</span> <span class="dt">Integer</span> <span class="fu">|</span> <span class="dt">V</span> <span class="dt">Var</span> 
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span> 
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Subtr</span> <span class="dt">Expr</span> <span class="dt">Expr</span> 
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Mult</span> <span class="dt">Expr</span> <span class="dt">Expr</span> 
<span class="ot">&gt;</span>           <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</code></pre></div>
<p><strong>Evaluation of an expression in an environment</strong></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> 
<span class="ot">&gt;</span> eval _ (<span class="dt">I</span> i) <span class="fu">=</span> i 
<span class="ot">&gt;</span> eval c (<span class="dt">V</span> name) <span class="fu">=</span> c name
<span class="ot">&gt;</span> eval c (<span class="dt">Add</span> e1 e2)   <span class="fu">=</span> (eval c e1) <span class="fu">+</span> (eval c e2)
<span class="ot">&gt;</span> eval c (<span class="dt">Subtr</span> e1 e2) <span class="fu">=</span> (eval c e1) <span class="fu">-</span> (eval c e2)
<span class="ot">&gt;</span> eval c (<span class="dt">Mult</span> e1 e2)  <span class="fu">=</span> (eval c e1) <span class="fu">*</span> (eval c e2)</code></pre></div>
<p><strong>Variable Assignment in an Environment</strong></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; assign ::</span> <span class="dt">Var</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> 
<span class="ot">&gt;</span> assign var expr c <span class="fu">=</span> <span class="kw">let</span> 
<span class="ot">&gt;</span>    value <span class="fu">=</span> eval c expr 
<span class="ot">&gt;</span>  <span class="kw">in</span> 
<span class="ot">&gt;</span>    update c (var,value)</code></pre></div>
<p><strong>Environment initialisation</strong></p>
<p>An environment is a finite object, so it will yield <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-10-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x22A5;&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-84" role="math" style="width: 0.853em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.792em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.277em 1000.73em 2.309em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-85"><span class="mi" id="MathJax-Span-86" style="font-family: MathJax_Main;">⊥</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.816em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">⊥</mi></math></span></span><script type="math/tex" id="MathJax-Element-10">\bot</script></span> (undefined) for all but a finite number of variables.</p>
<p>The initial environment is everywhere undefined:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; initEnv ::</span> <span class="dt">Env</span> 
<span class="ot">&gt;</span> initEnv <span class="fu">=</span> \ _ <span class="ot">-&gt;</span> undefined</code></pre></div>
<p><strong>Simple example</strong></p>
<pre><code> initialize an environment; 
 x := 3; 
 y := 5; 
 x := x*y; 
 evaluate x</code></pre>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> example <span class="fu">=</span> initEnv <span class="fu">$$</span> 
<span class="ot">&gt;</span>           assign <span class="st">"x"</span> (<span class="dt">I</span> <span class="dv">3</span>) <span class="fu">#</span> 
<span class="ot">&gt;</span>           assign <span class="st">"y"</span> (<span class="dt">I</span> <span class="dv">5</span>) <span class="fu">#</span> 
<span class="ot">&gt;</span>           assign <span class="st">"x"</span> (<span class="dt">Mult</span> (<span class="dt">V</span> <span class="st">"x"</span>) (<span class="dt">V</span> <span class="st">"y"</span>)) <span class="fu">#</span>
<span class="ot">&gt;</span>           flip eval (<span class="dt">V</span> <span class="st">"x"</span>)</code></pre></div>
<pre><code> *Lecture3&gt; :t example
 example :: Integer
 *Lecture3&gt; example
 15</code></pre>
<p><strong>A closer look at <em>while</em> loops</strong></p>
<p>Joke about the computer scientist who died under the shower...</p>
<p>He read the text on the shampoo bottle and followed the instruction:</p>
<pre><code>lather; rinse; repeat</code></pre>
<p>This is an infinite loop. In many cases we need to add a stop condition:</p>
<pre><code>until clean (lather # rinse)</code></pre>
<p>or</p>
<pre><code>while (not.clean) (lather # rinse)</code></pre>
<p>The <code>until</code> function is predefined in Haskell.</p>
<p><strong>Review question</strong> Can you give a type specification of <code>until</code>? Can you give a definition?</p>
<p>Here is a definition of <code>while</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; while ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> while <span class="fu">=</span> until <span class="fu">.</span> (not<span class="fu">.</span>)</code></pre></div>
<p>Check the types!</p>
<p>Famous example:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> euclid m n <span class="fu">=</span> (m,n) <span class="fu">$$</span>
<span class="ot">&gt;</span>    while (\ (x,y) <span class="ot">-&gt;</span> x <span class="fu">/=</span> y) 
<span class="ot">&gt;</span>          (\ (x,y) <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="fu">&gt;</span> y <span class="kw">then</span> (x<span class="fu">-</span>y,y) 
<span class="ot">&gt;</span>                               <span class="kw">else</span> (x,y<span class="fu">-</span>x)) <span class="fu">#</span>
<span class="ot">&gt;</span>          fst</code></pre></div>
<p><strong>While + Return</strong></p>
<p>Sometimes it is useful to include a function for transforming the result:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; whiler ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> whiler p f r <span class="fu">=</span> while p f <span class="fu">#</span> r</code></pre></div>
<p>Example:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> euclid2 m n <span class="fu">=</span> (m,n) <span class="fu">$$</span>
<span class="ot">&gt;</span>           whiler (\ (x,y) <span class="ot">-&gt;</span> x <span class="fu">/=</span> y) 
<span class="ot">&gt;</span>                  (\ (x,y) <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="fu">&gt;</span> y <span class="kw">then</span> (x<span class="fu">-</span>y,y) 
<span class="ot">&gt;</span>                                       <span class="kw">else</span> (x,y<span class="fu">-</span>x))
<span class="ot">&gt;</span>                  fst</code></pre></div>
<p>Now we can compute the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a> in <em>functional imperative style</em>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fibonacci ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> fibonacci n <span class="fu">=</span> fibon (<span class="dv">0</span>,<span class="dv">1</span>,n) <span class="kw">where</span>
<span class="ot">&gt;</span>   fibon <span class="fu">=</span> whiler 
<span class="ot">&gt;</span>            (\ (_,_,n) <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">0</span>)
<span class="ot">&gt;</span>            (\ (x,y,n) <span class="ot">-&gt;</span> (y,x<span class="fu">+</span>y,n<span class="fu">-</span><span class="dv">1</span>))
<span class="ot">&gt;</span>            (\ (x,_,_) <span class="ot">-&gt;</span> x)</code></pre></div>
<p>Also compare:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fb ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> fb n <span class="fu">=</span> fb' <span class="dv">0</span> <span class="dv">1</span> n <span class="kw">where</span> 
<span class="ot">&gt;</span>    fb' x y <span class="dv">0</span> <span class="fu">=</span> x 
<span class="ot">&gt;</span>    fb' x y n <span class="fu">=</span> fb' y (x<span class="fu">+</span>y) (n<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
<p>Clearly, these are two versions of the same algorithm.</p>
<p>Really different is the following:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)</code></pre></div>
<p><strong>Review question</strong> Try to explain what is going on here.</p>
<p><strong>Back to Hoare Logic</strong></p>
<p>First, let us implement the Hoare triple test. In order to actually <em>run</em> Hoare tests, we need a domain of test instances. In the previous lecture we have seen how test instances can be generated. Here we just assume that we have test instances available.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; hoareTest ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> hoareTest precondition f postcondition <span class="fu">=</span>
<span class="ot">&gt;</span>     all (\x <span class="ot">-&gt;</span> not (precondition x) <span class="fu">||</span> postcondition (f x)) </code></pre></div>
<p>An example:</p>
<pre><code> hoareTest odd succ even [0..100]</code></pre>
<p><strong>Recognizing the Relevant Test Cases</strong></p>
<p>The <em>relevant</em> test cases are the cases that satisfy the precondition. The following function keeps track of the proportion of relevant tests:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; hoareTestR ::</span>  <span class="dt">Fractional</span> t <span class="ot">=&gt;</span>
<span class="ot">&gt;</span>                (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> (<span class="dt">Bool</span>,t)
<span class="ot">&gt;</span> hoareTestR precondition f postcondition testcases <span class="fu">=</span> <span class="kw">let</span>
<span class="ot">&gt;</span>        a <span class="fu">=</span> fromIntegral (length <span class="fu">$</span> filter precondition testcases)
<span class="ot">&gt;</span>        b <span class="fu">=</span> fromIntegral (length testcases)
<span class="ot">&gt;</span>      <span class="kw">in</span> 
<span class="ot">&gt;</span>        (all (\x <span class="ot">-&gt;</span> not (precondition x) <span class="fu">||</span> postcondition (f x)) testcases,a<span class="fu">/</span>b)</code></pre></div>
<p>This gives:</p>
<pre><code>*Lecture3&gt;  hoareTest odd succ even [0..100]
True
*Lecture3&gt;  hoareTestR odd succ even [0..100]
(True,0.49504950495049505)
*Lecture3&gt;  hoareTestR (\_ -&gt; True) succ even [0..100]
(False,1.0)
          </code></pre>
<p>The Hoare rule for while statements:</p>
<p>From</p>
<pre><code>{ p } f { p }    </code></pre>
<p>derive</p>
<pre><code>{ p } while c f { p .&amp;&amp;. not.c }</code></pre>
<p>The property <code>p</code> in statement <code>{ p } f { p }</code> is called a <a href="https://en.wikipedia.org/wiki/Loop_invariant">loop invariant</a>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; invarTest ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> invarTest invar f <span class="fu">=</span> hoareTest invar f invar             </code></pre></div>
<p>Example use:</p>
<pre><code>    invarTest odd (succ.succ) [0..100]
    </code></pre>
<p>Again, we can implement a variation for keeping track of the proportion of relevant tests.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; invarTestR ::</span>  <span class="dt">Fractional</span> t <span class="ot">=&gt;</span>
<span class="ot">&gt;</span>                (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> (<span class="dt">Bool</span>,t)
<span class="ot">&gt;</span> invarTestR invar f <span class="fu">=</span> hoareTestR invar f invar             </code></pre></div>
<p>This gives:</p>
<pre><code>*Lecture3&gt; invarTest odd (succ.succ) [0..100]
True
*Lecture3&gt; invarTestR odd (succ.succ) [0..100]
(True,0.49504950495049505)</code></pre>
<p>If you want further instruction on Hoare logic, you can do no better than consult <a href="http://www.cl.cam.ac.uk/~mjcg/Teaching/2011/Hoare/Notes/Notes.pdf">Mike Gordon's notes</a>.</p>
<hr>
<p><strong>Note</strong></p>
<p>Hoare triples have a limitation: they do not allow us to express <em>relations</em> between inputs and outputs of functions.</p>
<p>In many cases, we want to check whether input and output are mapped to the same image by some test function. For instance, what we would like to say is that <code>succ.succ</code> preserves parity.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> parity n <span class="fu">=</span> mod n <span class="dv">2</span>    </code></pre></div>
<p>To say this, we need a relational version of Hoare tests:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; testRel ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> testRel spec f <span class="fu">=</span> all (\x <span class="ot">-&gt;</span> spec x (f x))</code></pre></div>
<p>Now we can use <code>parity</code> to specify an invariant relation:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; testInvar ::</span> <span class="dt">Eq</span> b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> testInvar specf <span class="fu">=</span> testRel (\ x y <span class="ot">-&gt;</span> specf x <span class="fu">==</span> specf y)</code></pre></div>
<p>Example use:</p>
<pre><code> testInvar parity (succ.succ) [0..100]
  </code></pre>
<hr>
<p><strong>The Logic of Boolean Conditions</strong></p>
<p>The Boolean conditions of any imperative programming language are in fact statements of <a href="https://en.wikipedia.org/wiki/Propositional_calculus">propositional logic</a>.</p>
<p>Here is a datatype for propositional formulas:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">Int</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Form</span> <span class="fu">=</span> <span class="dt">Prop</span> <span class="dt">Name</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Neg</span>  <span class="dt">Form</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Cnj</span> [<span class="dt">Form</span>]
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Dsj</span> [<span class="dt">Form</span>]
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Impl</span> <span class="dt">Form</span> <span class="dt">Form</span> 
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Equiv</span> <span class="dt">Form</span> <span class="dt">Form</span> 
<span class="ot">&gt;</span>           <span class="kw">deriving</span> <span class="dt">Eq</span></code></pre></div>
<p>This time, we define our own <code>show</code> function for formulas:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Form</span> <span class="kw">where</span> 
<span class="ot">&gt;</span>   show (<span class="dt">Prop</span> x)   <span class="fu">=</span> show x
<span class="ot">&gt;</span>   show (<span class="dt">Neg</span> f)    <span class="fu">=</span> <span class="ch">'-'</span> <span class="fu">:</span> show f 
<span class="ot">&gt;</span>   show (<span class="dt">Cnj</span> fs)     <span class="fu">=</span> <span class="st">"*("</span> <span class="fu">++</span> showLst fs <span class="fu">++</span> <span class="st">")"</span>
<span class="ot">&gt;</span>   show (<span class="dt">Dsj</span> fs)     <span class="fu">=</span> <span class="st">"+("</span> <span class="fu">++</span> showLst fs <span class="fu">++</span> <span class="st">")"</span>
<span class="ot">&gt;</span>   show (<span class="dt">Impl</span> f1 f2)  <span class="fu">=</span> <span class="st">"("</span> <span class="fu">++</span> show f1 <span class="fu">++</span> <span class="st">"==&gt;"</span> 
<span class="ot">&gt;</span>                            <span class="fu">++</span> show f2 <span class="fu">++</span> <span class="st">")"</span>
<span class="ot">&gt;</span>   show (<span class="dt">Equiv</span> f1 f2)  <span class="fu">=</span> <span class="st">"("</span> <span class="fu">++</span> show f1 <span class="fu">++</span> <span class="st">"&lt;=&gt;"</span> 
<span class="ot">&gt;</span>                            <span class="fu">++</span> show f2 <span class="fu">++</span> <span class="st">")"</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> showLst,<span class="ot">showRest ::</span> [<span class="dt">Form</span>] <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">&gt;</span> showLst [] <span class="fu">=</span> <span class="st">""</span>
<span class="ot">&gt;</span> showLst (f<span class="fu">:</span>fs) <span class="fu">=</span> show f <span class="fu">++</span> showRest fs
<span class="ot">&gt;</span> showRest [] <span class="fu">=</span> <span class="st">""</span>
<span class="ot">&gt;</span> showRest (f<span class="fu">:</span>fs) <span class="fu">=</span> <span class="ch">' '</span><span class="fu">:</span> show f <span class="fu">++</span> showRest fs</code></pre></div>
<p>Example Formulas:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> p <span class="fu">=</span> <span class="dt">Prop</span> <span class="dv">1</span>
<span class="ot">&gt;</span> q <span class="fu">=</span> <span class="dt">Prop</span> <span class="dv">2</span>
<span class="ot">&gt;</span> r <span class="fu">=</span> <span class="dt">Prop</span> <span class="dv">3</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> form1 <span class="fu">=</span> <span class="dt">Equiv</span> (<span class="dt">Impl</span> p q) (<span class="dt">Impl</span> (<span class="dt">Neg</span> q) (<span class="dt">Neg</span> p))
<span class="ot">&gt;</span> form2 <span class="fu">=</span> <span class="dt">Equiv</span> (<span class="dt">Impl</span> p q) (<span class="dt">Impl</span> (<span class="dt">Neg</span> p) (<span class="dt">Neg</span> q))
<span class="ot">&gt;</span> form3 <span class="fu">=</span> <span class="dt">Impl</span> (<span class="dt">Cnj</span> [<span class="dt">Impl</span> p q, <span class="dt">Impl</span> q r]) (<span class="dt">Impl</span> p r)</code></pre></div>
<p><strong>Proposition Letters Occurring in a Formula</strong></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; propNames ::</span> <span class="dt">Form</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
<span class="ot">&gt;</span> propNames <span class="fu">=</span> sort<span class="fu">.</span>nub<span class="fu">.</span>pnames <span class="kw">where</span> 
<span class="ot">&gt;</span>   pnames (<span class="dt">Prop</span> name) <span class="fu">=</span> [name]
<span class="ot">&gt;</span>   pnames (<span class="dt">Neg</span> f)  <span class="fu">=</span> pnames f
<span class="ot">&gt;</span>   pnames (<span class="dt">Cnj</span> fs) <span class="fu">=</span> concat (map pnames fs)
<span class="ot">&gt;</span>   pnames (<span class="dt">Dsj</span> fs) <span class="fu">=</span> concat (map pnames fs)
<span class="ot">&gt;</span>   pnames (<span class="dt">Impl</span> f1 f2)  <span class="fu">=</span> concat (map pnames [f1,f2])
<span class="ot">&gt;</span>   pnames (<span class="dt">Equiv</span> f1 f2) <span class="fu">=</span> concat (map pnames [f1,f2])</code></pre></div>
<p><strong>Valuations</strong></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Valuation</span> <span class="fu">=</span> [(<span class="dt">Name</span>,<span class="dt">Bool</span>)]
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | all possible valuations for lists of prop letters</span>
<span class="ot">&gt; genVals ::</span> [<span class="dt">Name</span>] <span class="ot">-&gt;</span> [<span class="dt">Valuation</span>]
<span class="ot">&gt;</span> genVals [] <span class="fu">=</span> [[]]
<span class="ot">&gt;</span> genVals (name<span class="fu">:</span>names) <span class="fu">=</span> 
<span class="ot">&gt;</span>   map ((name,<span class="dt">True</span>) <span class="fu">:</span>) (genVals names)
<span class="ot">&gt;</span>   <span class="fu">++</span> map ((name,<span class="dt">False</span>)<span class="fu">:</span>) (genVals names)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | generate all possible valuations for a formula</span>
<span class="ot">&gt; allVals ::</span> <span class="dt">Form</span> <span class="ot">-&gt;</span> [<span class="dt">Valuation</span>]
<span class="ot">&gt;</span> allVals <span class="fu">=</span> genVals <span class="fu">.</span> propNames</code></pre></div>
<p>Note that an exponential blowup takes place here. If a propositional formula has n variables, there are <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-11-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msup&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-87" role="math" style="width: 1.095em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.035em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(0.064em 1001.04em 1.156em -999.997em); top: -0.968em; left: 0.003em;"><span class="mrow" id="MathJax-Span-88"><span class="msubsup" id="MathJax-Span-89"><span style="display: inline-block; position: relative; width: 0.974em; height: 0px;"><span style="position: absolute; clip: rect(3.158em 1000.43em 4.19em -999.997em); top: -4.002em; left: 0.003em;"><span class="mn" id="MathJax-Span-90" style="font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span><span style="position: absolute; top: -4.366em; left: 0.488em;"><span class="mi" id="MathJax-Span-91" style="font-size: 70.7%; font-family: MathJax_Math-italic;">n</span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 0.974em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.878em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>n</mi></msup></math></span></span><script type="math/tex" id="MathJax-Element-11">2^n</script></span> different valuations for that formula. To see what that means, just look at this:</p>
<pre><code> *Lecture3&gt; map (2^) [1..20]
 [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,
 16384,32768,65536,131072,262144,524288,1048576]</code></pre>
<p>We might as well have defined valuations as environments with boolean values:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">ValFct</span> <span class="fu">=</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre></div>
<p>It is all a matter of representation. We can easily move back and forth between the two representations.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; val2fct ::</span> <span class="dt">Valuation</span> <span class="ot">-&gt;</span> <span class="dt">ValFct</span>
<span class="ot">&gt;</span> val2fct <span class="fu">=</span> updates (\ _ <span class="ot">-&gt;</span> undefined)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fct2val ::</span> [<span class="dt">Name</span>] <span class="ot">-&gt;</span> <span class="dt">ValFct</span> <span class="ot">-&gt;</span> <span class="dt">Valuation</span>
<span class="ot">&gt;</span> fct2val domain f <span class="fu">=</span> map (\x <span class="ot">-&gt;</span> (x,f x)) domain </code></pre></div>
<p>Evaluation of formulas.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; evl ::</span> <span class="dt">Valuation</span> <span class="ot">-&gt;</span> <span class="dt">Form</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> evl [] (<span class="dt">Prop</span> c)    <span class="fu">=</span> error (<span class="st">"no info: "</span> <span class="fu">++</span> show c)
<span class="ot">&gt;</span> evl ((i,b)<span class="fu">:</span>xs) (<span class="dt">Prop</span> c)
<span class="ot">&gt;</span>      <span class="fu">|</span> c <span class="fu">==</span> i    <span class="fu">=</span> b
<span class="ot">&gt;</span>      <span class="fu">|</span> otherwise <span class="fu">=</span> evl xs (<span class="dt">Prop</span> c)
<span class="ot">&gt;</span> evl xs (<span class="dt">Neg</span> f)  <span class="fu">=</span> not (evl xs f)
<span class="ot">&gt;</span> evl xs (<span class="dt">Cnj</span> fs) <span class="fu">=</span> all (evl xs) fs
<span class="ot">&gt;</span> evl xs (<span class="dt">Dsj</span> fs) <span class="fu">=</span> any (evl xs) fs
<span class="ot">&gt;</span> evl xs (<span class="dt">Impl</span> f1 f2) <span class="fu">=</span> 
<span class="ot">&gt;</span>     not (evl xs f1) <span class="fu">||</span> evl xs f2
<span class="ot">&gt;</span> evl xs (<span class="dt">Equiv</span> f1 f2) <span class="fu">=</span> evl xs f1 <span class="fu">==</span> evl xs f2</code></pre></div>
<p>Note that the evaluation algorithm is feasible: <code>evl</code> is called only once for each subformula. Finding a satisfying valuation for a formula is hard, but checking whether a valuation satisfies a formula is easy.</p>
<p><strong>Satisfiability, Logical Entailment, Equivalence</strong></p>
<p>A formula is satisfiable if some valuation makes it true. We know what the valuations of a formula <code>f</code> are. These are given by <code>allVals f</code>. We also know how to express that a valuation <code>v</code> makes a formula <code>f</code> true: <code>eval v f</code>. This gives:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; satisfiable ::</span> <span class="dt">Form</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> satisfiable f <span class="fu">=</span> any (\ v <span class="ot">-&gt;</span> evl v f) (allVals f)</code></pre></div>
<p><strong>Lab Exercise for this week</strong></p>
<p>Write implementations of contradiction, tautology, logical entailment, logical equivalence, and test them.</p>
<hr>
<p><strong>Parsing Propositional Formulas</strong></p>
<p>The process of converting an input string to a list of tokens is called <code>lexical scanning</code>. The following is a relevant list of tokens for propositional formulas.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Token</span> 
<span class="ot">&gt;</span>       <span class="fu">=</span> <span class="dt">TokenNeg</span>
<span class="ot">&gt;</span>       <span class="fu">|</span> <span class="dt">TokenCnj</span>
<span class="ot">&gt;</span>       <span class="fu">|</span> <span class="dt">TokenDsj</span>
<span class="ot">&gt;</span>       <span class="fu">|</span> <span class="dt">TokenImpl</span>
<span class="ot">&gt;</span>       <span class="fu">|</span> <span class="dt">TokenEquiv</span> 
<span class="ot">&gt;</span>       <span class="fu">|</span> <span class="dt">TokenInt</span> <span class="dt">Int</span> 
<span class="ot">&gt;</span>       <span class="fu">|</span> <span class="dt">TokenOP</span>
<span class="ot">&gt;</span>       <span class="fu">|</span> <span class="dt">TokenCP</span>
<span class="ot">&gt;</span>  <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>)</code></pre></div>
<p>The lexer converts a string to a list of tokens.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; lexer ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Token</span>]
<span class="ot">&gt;</span> lexer [] <span class="fu">=</span> []
<span class="ot">&gt;</span> lexer (c<span class="fu">:</span>cs) <span class="fu">|</span> isSpace c <span class="fu">=</span> lexer cs
<span class="ot">&gt;</span>              <span class="fu">|</span> isDigit c <span class="fu">=</span> lexNum (c<span class="fu">:</span>cs) 
<span class="ot">&gt;</span> lexer (<span class="ch">'('</span><span class="fu">:</span>cs) <span class="fu">=</span> <span class="dt">TokenOP</span> <span class="fu">:</span> lexer cs
<span class="ot">&gt;</span> lexer (<span class="ch">')'</span><span class="fu">:</span>cs) <span class="fu">=</span> <span class="dt">TokenCP</span> <span class="fu">:</span> lexer cs
<span class="ot">&gt;</span> lexer (<span class="ch">'*'</span><span class="fu">:</span>cs) <span class="fu">=</span> <span class="dt">TokenCnj</span> <span class="fu">:</span> lexer cs
<span class="ot">&gt;</span> lexer (<span class="ch">'+'</span><span class="fu">:</span>cs) <span class="fu">=</span> <span class="dt">TokenDsj</span> <span class="fu">:</span> lexer cs
<span class="ot">&gt;</span> lexer (<span class="ch">'-'</span><span class="fu">:</span>cs) <span class="fu">=</span> <span class="dt">TokenNeg</span> <span class="fu">:</span> lexer cs 
<span class="ot">&gt;</span> lexer (<span class="ch">'='</span><span class="fu">:</span><span class="ch">'='</span><span class="fu">:</span><span class="ch">'&gt;'</span><span class="fu">:</span>cs) <span class="fu">=</span> <span class="dt">TokenImpl</span> <span class="fu">:</span> lexer cs
<span class="ot">&gt;</span> lexer (<span class="ch">'&lt;'</span><span class="fu">:</span><span class="ch">'='</span><span class="fu">:</span><span class="ch">'&gt;'</span><span class="fu">:</span>cs) <span class="fu">=</span> <span class="dt">TokenEquiv</span> <span class="fu">:</span> lexer cs
<span class="ot">&gt;</span> lexer (x<span class="fu">:</span>_) <span class="fu">=</span> error (<span class="st">"unknown token: "</span> <span class="fu">++</span> [x])</code></pre></div>
<p>Read an integer and convert it into a structured token of the form <code>TokenInt i</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> lexNum cs <span class="fu">=</span> <span class="dt">TokenInt</span> (read num) <span class="fu">:</span> lexer rest
<span class="ot">&gt;</span>      <span class="kw">where</span> (num,rest) <span class="fu">=</span> span isDigit cs</code></pre></div>
<p>Example use:</p>
<pre><code> *Lecture3&gt; lexer "*(2 3 -4 +("
 [TokenCnj,TokenOP,TokenInt 2,TokenInt 3,TokenNeg,TokenInt 4,TokenDsj,TokenOP]</code></pre>
<p>A <em>parser</em> for token type <code>a</code> that constructs a datatype <code>b</code> has the following type:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Parser</span> a b <span class="fu">=</span> [a] <span class="ot">-&gt;</span> [(b,[a])]</code></pre></div>
<p>The parser constructs a list of tuples <code>(b,[a])</code> from an initial segment of a token string <code>[a]</code>. The remainder list in the second element of the result is the list of tokens that were not used in the construction of the datatype.</p>
<p>If the output list is empty, the parse has not succeeded. If the output list more than one element, the token list was ambiguous.</p>
<p>The simplest possible parser is the parser that succeeds immediately, while consuming no input:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; succeed ::</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> a b
<span class="ot">&gt;</span> succeed x xs <span class="fu">=</span> [(x,xs)]</code></pre></div>
<p>Parsing a formula.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; parseForm ::</span> <span class="dt">Parser</span> <span class="dt">Token</span> <span class="dt">Form</span> 
<span class="ot">&gt;</span> parseForm (<span class="dt">TokenInt</span> x<span class="fu">:</span> tokens) <span class="fu">=</span> [(<span class="dt">Prop</span> x,tokens)]
<span class="ot">&gt;</span> parseForm (<span class="dt">TokenNeg</span> <span class="fu">:</span> tokens) <span class="fu">=</span>
<span class="ot">&gt;</span>   [ (<span class="dt">Neg</span> f, rest) <span class="fu">|</span> (f,rest) <span class="ot">&lt;-</span> parseForm tokens ]
<span class="ot">&gt;</span> parseForm (<span class="dt">TokenCnj</span> <span class="fu">:</span> <span class="dt">TokenOP</span> <span class="fu">:</span> tokens) <span class="fu">=</span> 
<span class="ot">&gt;</span>   [ (<span class="dt">Cnj</span> fs, rest) <span class="fu">|</span> (fs,rest) <span class="ot">&lt;-</span> parseForms tokens ]
<span class="ot">&gt;</span> parseForm (<span class="dt">TokenDsj</span> <span class="fu">:</span> <span class="dt">TokenOP</span> <span class="fu">:</span> tokens) <span class="fu">=</span> 
<span class="ot">&gt;</span>   [ (<span class="dt">Dsj</span> fs, rest) <span class="fu">|</span> (fs,rest) <span class="ot">&lt;-</span> parseForms tokens ]
<span class="ot">&gt;</span> parseForm (<span class="dt">TokenOP</span> <span class="fu">:</span> tokens) <span class="fu">=</span> 
<span class="ot">&gt;</span>   [ (<span class="dt">Impl</span> f1 f2, rest) <span class="fu">|</span> (f1,ys) <span class="ot">&lt;-</span> parseForm tokens,
<span class="ot">&gt;</span>                          (f2,rest) <span class="ot">&lt;-</span> parseImpl ys ]
<span class="ot">&gt;</span>    <span class="fu">++</span>
<span class="ot">&gt;</span>   [ (<span class="dt">Equiv</span> f1 f2, rest) <span class="fu">|</span> (f1,ys) <span class="ot">&lt;-</span> parseForm tokens,
<span class="ot">&gt;</span>                           (f2,rest) <span class="ot">&lt;-</span> parseEquiv ys ] 
<span class="ot">&gt;</span> parseForm tokens <span class="fu">=</span> []</code></pre></div>
<p>Parsing a list of formulas: success if a closing parenthesis is encountered. This uses the <code>succeed</code> parser above.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; parseForms ::</span> <span class="dt">Parser</span> <span class="dt">Token</span> [<span class="dt">Form</span>] 
<span class="ot">&gt;</span> parseForms (<span class="dt">TokenCP</span> <span class="fu">:</span> tokens) <span class="fu">=</span> succeed [] tokens
<span class="ot">&gt;</span> parseForms tokens <span class="fu">=</span> 
<span class="ot">&gt;</span>    [(f<span class="fu">:</span>fs, rest) <span class="fu">|</span> (f,ys) <span class="ot">&lt;-</span> parseForm tokens, 
<span class="ot">&gt;</span>                    (fs,rest) <span class="ot">&lt;-</span> parseForms ys ]</code></pre></div>
<p>Parsing implications and equivalences uses separate functions, for these constructions have infix operators.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; parseImpl ::</span> <span class="dt">Parser</span> <span class="dt">Token</span> <span class="dt">Form</span>
<span class="ot">&gt;</span> parseImpl (<span class="dt">TokenImpl</span> <span class="fu">:</span> tokens) <span class="fu">=</span> 
<span class="ot">&gt;</span>   [ (f,ys) <span class="fu">|</span> (f,y<span class="fu">:</span>ys) <span class="ot">&lt;-</span> parseForm tokens, y <span class="fu">==</span> <span class="dt">TokenCP</span> ]
<span class="ot">&gt;</span> parseImpl tokens <span class="fu">=</span> []
<span class="ot">&gt;</span> 
<span class="ot">&gt; parseEquiv ::</span> <span class="dt">Parser</span> <span class="dt">Token</span> <span class="dt">Form</span>
<span class="ot">&gt;</span> parseEquiv (<span class="dt">TokenEquiv</span> <span class="fu">:</span> tokens) <span class="fu">=</span> 
<span class="ot">&gt;</span>   [ (f,ys) <span class="fu">|</span> (f,y<span class="fu">:</span>ys) <span class="ot">&lt;-</span> parseForm tokens, y <span class="fu">==</span> <span class="dt">TokenCP</span> ]
<span class="ot">&gt;</span> parseEquiv tokens <span class="fu">=</span> []</code></pre></div>
<p>The parse function.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Form</span>]
<span class="ot">&gt;</span> parse s <span class="fu">=</span> [ f <span class="fu">|</span> (f,_) <span class="ot">&lt;-</span> parseForm (lexer s) ]</code></pre></div>
<p>This gives:</p>
<pre><code> *Lecture3&gt; parse "*(1 +(2 -3))"
 [*(1 +(2 -3))]
 *Lecture3&gt; parse "*(1 +(2 -3)"
 []
 *Lecture3&gt; parse "*(1 +(2 -3))))"
 [*(1 +(2 -3))]
 *Lecture3&gt; parseForm (lexer "*(1 +(2 -3))))")
 [(*(1 +(2 -3)),[TokenCP,TokenCP])]</code></pre>
<p><strong>Lab Exercise for this week</strong></p>
<p>Write an appropriate test for the parse function. Hint: use the <code>show</code> function for formulas.</p>
<hr>
<p><strong>Conjunctive Normal Form</strong></p>
<p><a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">Conjunctive normal form</a> or CNF and <a href="https://en.wikipedia.org/wiki/Disjunctive_normal_form">disjunctive normal form</a> or DNF are important for automated theorem proving: CNF formulas can easily be tested for validity, by checking that each clause contains some letter <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-12-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-92" role="math" style="width: 0.61em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.549em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.338em 1000.55em 2.309em -999.997em); top: -1.939em; left: 0.003em;"><span class="mrow" id="MathJax-Span-93"><span class="mi" id="MathJax-Span-94" style="font-family: MathJax_Math-italic;">p</span></span><span style="display: inline-block; width: 0px; height: 1.945em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.753em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi></math></span></span><script type="math/tex" id="MathJax-Element-12">p</script></span> and its negation <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-13-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-95" role="math" style="width: 1.277em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.217em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.52em 1001.22em 2.491em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-96"><span class="mi" id="MathJax-Span-97" style="font-family: MathJax_Main;">¬</span><span class="mi" id="MathJax-Span-98" style="font-family: MathJax_Math-italic;">p</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.753em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">¬</mi><mi>p</mi></math></span></span><script type="math/tex" id="MathJax-Element-13">\neg p</script></span>. Automated theorem provers often start out from formulas in CNF.</p>
<p><strong>First Step</strong></p>
<p>The first step for converting to CNF is to translate into an equivalent formula that is arrow-free: a formula without <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-14-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x2194;&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-99" role="math" style="width: 1.095em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.035em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.459em 1000.97em 2.309em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-100"><span class="mo" id="MathJax-Span-101" style="font-family: MathJax_Main;">↔</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.691em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">↔</mo></math></span></span><script type="math/tex" id="MathJax-Element-14">\leftrightarrow</script></span> and <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-15-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x2192;&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-102" role="math" style="width: 1.095em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.035em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.459em 1000.97em 2.309em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-103"><span class="mo" id="MathJax-Span-104" style="font-family: MathJax_Main;">→</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.691em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">→</mo></math></span></span><script type="math/tex" id="MathJax-Element-15">\rightarrow</script></span> operators. Here is the recipe:</p>
<ul>
<li><p>Use the equivalence between <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-16-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x2192;&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-105" role="math" style="width: 2.734em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.612em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.459em 1002.61em 2.491em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-106"><span class="mi" id="MathJax-Span-107" style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-108" style="font-family: MathJax_Main; padding-left: 0.306em;">→</span><span class="mi" id="MathJax-Span-109" style="font-family: MathJax_Math-italic; padding-left: 0.306em;">q<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.878em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mo stretchy="false">→</mo><mi>q</mi></math></span></span><script type="math/tex" id="MathJax-Element-16">p \rightarrow q</script></span> and <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-17-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;&amp;#x2228;&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-110" role="math" style="width: 2.916em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.794em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.338em 1002.79em 2.491em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-111"><span class="mi" id="MathJax-Span-112" style="font-family: MathJax_Main;">¬</span><span class="mi" id="MathJax-Span-113" style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-114" style="font-family: MathJax_Main; padding-left: 0.246em;">∨</span><span class="mi" id="MathJax-Span-115" style="font-family: MathJax_Math-italic; padding-left: 0.246em;">q<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.941em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">¬</mi><mi>p</mi><mo>∨</mo><mi>q</mi></math></span></span><script type="math/tex" id="MathJax-Element-17">\neg p \lor q</script></span> to get rid of <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-18-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x2192;&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-116" role="math" style="width: 1.095em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.035em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.459em 1000.97em 2.309em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-117"><span class="mo" id="MathJax-Span-118" style="font-family: MathJax_Main;">→</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.691em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">→</mo></math></span></span><script type="math/tex" id="MathJax-Element-18">\rightarrow</script></span> symbols.</p></li>
<li><p>Use the equivalence of <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-19-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x2194;&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-119" role="math" style="width: 2.734em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.612em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.459em 1002.61em 2.491em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-120"><span class="mi" id="MathJax-Span-121" style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-122" style="font-family: MathJax_Main; padding-left: 0.306em;">↔</span><span class="mi" id="MathJax-Span-123" style="font-family: MathJax_Math-italic; padding-left: 0.306em;">q<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.878em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mo stretchy="false">↔</mo><mi>q</mi></math></span></span><script type="math/tex" id="MathJax-Element-19">p \leftrightarrow q</script></span> and <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-20-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;&amp;#x2227;&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;&amp;#x2228;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;&amp;#x2227;&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-124" role="math" style="width: 8.498em; display: inline-block;"><span style="display: inline-block; position: relative; width: 8.255em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.217em 1008.13em 2.552em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-125"><span class="mo" id="MathJax-Span-126" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-127" style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-128" style="font-family: MathJax_Main; padding-left: 0.246em;">∧</span><span class="mi" id="MathJax-Span-129" style="font-family: MathJax_Math-italic; padding-left: 0.246em;">q<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-130" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-131" style="font-family: MathJax_Main; padding-left: 0.246em;">∨</span><span class="mo" id="MathJax-Span-132" style="font-family: MathJax_Main; padding-left: 0.246em;">(</span><span class="mi" id="MathJax-Span-133" style="font-family: MathJax_Main;">¬</span><span class="mi" id="MathJax-Span-134" style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-135" style="font-family: MathJax_Main; padding-left: 0.246em;">∧</span><span class="mi" id="MathJax-Span-136" style="font-family: MathJax_Main; padding-left: 0.246em;">¬</span><span class="mi" id="MathJax-Span-137" style="font-family: MathJax_Math-italic;">q<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-138" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>p</mi><mo>∧</mo><mi>q</mi><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>p</mi><mo>∧</mo><mi mathvariant="normal">¬</mi><mi>q</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-20">(p \land q) \lor (\neg p \land \neg q)</script></span>, to get rid of <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-21-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x2194;&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-139" role="math" style="width: 1.095em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.035em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.459em 1000.97em 2.309em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-140"><span class="mo" id="MathJax-Span-141" style="font-family: MathJax_Main;">↔</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.691em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">↔</mo></math></span></span><script type="math/tex" id="MathJax-Element-21">\leftrightarrow</script></span> symbols. (Equivalently: use the equivalence of <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-22-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x2194;&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-142" role="math" style="width: 2.734em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.612em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.459em 1002.61em 2.491em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-143"><span class="mi" id="MathJax-Span-144" style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-145" style="font-family: MathJax_Main; padding-left: 0.306em;">↔</span><span class="mi" id="MathJax-Span-146" style="font-family: MathJax_Math-italic; padding-left: 0.306em;">q<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.878em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mo stretchy="false">↔</mo><mi>q</mi></math></span></span><script type="math/tex" id="MathJax-Element-22">p \leftrightarrow q</script></span> and <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-23-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;&amp;#x2228;&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;&amp;#x2227;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;&amp;#x2228;&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-147" role="math" style="width: 8.498em; display: inline-block;"><span style="display: inline-block; position: relative; width: 8.255em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.217em 1008.13em 2.552em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-148"><span class="mo" id="MathJax-Span-149" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-150" style="font-family: MathJax_Main;">¬</span><span class="mi" id="MathJax-Span-151" style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-152" style="font-family: MathJax_Main; padding-left: 0.246em;">∨</span><span class="mi" id="MathJax-Span-153" style="font-family: MathJax_Math-italic; padding-left: 0.246em;">q<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-154" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-155" style="font-family: MathJax_Main; padding-left: 0.246em;">∧</span><span class="mo" id="MathJax-Span-156" style="font-family: MathJax_Main; padding-left: 0.246em;">(</span><span class="mi" id="MathJax-Span-157" style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-158" style="font-family: MathJax_Main; padding-left: 0.246em;">∨</span><span class="mi" id="MathJax-Span-159" style="font-family: MathJax_Main; padding-left: 0.246em;">¬</span><span class="mi" id="MathJax-Span-160" style="font-family: MathJax_Math-italic;">q<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-161" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>p</mi><mo>∨</mo><mi>q</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>p</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>q</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-23">(\neg p \lor q) \land (p \lor \neg q)</script></span>.)</p></li>
</ul>
<p>This conversion has no precondition: it should work for any formula.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; arrowfree ::</span> <span class="dt">Form</span> <span class="ot">-&gt;</span> <span class="dt">Form</span> 
<span class="ot">&gt;</span> arrowfree (<span class="dt">Prop</span> x) <span class="fu">=</span> <span class="dt">Prop</span> x 
<span class="ot">&gt;</span> arrowfree (<span class="dt">Neg</span> f) <span class="fu">=</span> <span class="dt">Neg</span> (arrowfree f)
<span class="ot">&gt;</span> arrowfree (<span class="dt">Cnj</span> fs) <span class="fu">=</span> <span class="dt">Cnj</span> (map arrowfree fs)
<span class="ot">&gt;</span> arrowfree (<span class="dt">Dsj</span> fs) <span class="fu">=</span> <span class="dt">Dsj</span> (map arrowfree fs)
<span class="ot">&gt;</span> arrowfree (<span class="dt">Impl</span> f1 f2) <span class="fu">=</span> 
<span class="ot">&gt;</span>   <span class="dt">Dsj</span> [<span class="dt">Neg</span> (arrowfree f1), arrowfree f2]
<span class="ot">&gt;</span> arrowfree (<span class="dt">Equiv</span> f1 f2) <span class="fu">=</span> 
<span class="ot">&gt;</span>   <span class="dt">Dsj</span> [<span class="dt">Cnj</span> [f1', f2'], <span class="dt">Cnj</span> [<span class="dt">Neg</span> f1', <span class="dt">Neg</span> f2']]
<span class="ot">&gt;</span>   <span class="kw">where</span> f1' <span class="fu">=</span> arrowfree f1
<span class="ot">&gt;</span>         f2' <span class="fu">=</span> arrowfree f2</code></pre></div>
<p>The postconditions are:</p>
<ul>
<li><p>The result should have no occurrences of <code>Impl</code> and <code>Equiv</code>.</p></li>
<li><p>The result should be logically equivalent to the original.</p></li>
</ul>
<p><strong>Second Step</strong></p>
<p>The second step of the translation into CNF is conversion to negation normal form. Here is the syntactic definition:</p>
<p><span class="math display"><span class="MathJax_Preview" style="color: inherit;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-24-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mi&gt;&amp;#x03D5;&lt;/mi&gt;&lt;mo&gt;::=&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;&amp;#x2223;&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;&amp;#x2223;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;&amp;#x03D5;&lt;/mi&gt;&lt;mo&gt;&amp;#x2227;&lt;/mo&gt;&lt;mi&gt;&amp;#x03D5;&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;&amp;#x2223;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;&amp;#x03D5;&lt;/mi&gt;&lt;mo&gt;&amp;#x2228;&lt;/mo&gt;&lt;mi&gt;&amp;#x03D5;&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-162" role="math" style="width: 13.535em; display: inline-block;"><span style="display: inline-block; position: relative; width: 13.11em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.217em 1012.99em 2.552em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-163"><span class="mi" id="MathJax-Span-164" style="font-family: MathJax_Math-italic;">ϕ</span><span class="mo" id="MathJax-Span-165" style="font-family: MathJax_Main; padding-left: 0.306em;">:<span style="font-family: MathJax_Main;">:</span><span style="font-family: MathJax_Main;">=</span></span><span class="mi" id="MathJax-Span-166" style="font-family: MathJax_Math-italic; padding-left: 0.306em;">p</span><span class="mo" id="MathJax-Span-167" style="font-family: MathJax_Main; padding-left: 0.306em;">∣</span><span class="mi" id="MathJax-Span-168" style="font-family: MathJax_Main; padding-left: 0.306em;">¬</span><span class="mi" id="MathJax-Span-169" style="font-family: MathJax_Math-italic;">p</span><span class="mo" id="MathJax-Span-170" style="font-family: MathJax_Main; padding-left: 0.306em;">∣</span><span class="mo" id="MathJax-Span-171" style="font-family: MathJax_Main; padding-left: 0.306em;">(</span><span class="mi" id="MathJax-Span-172" style="font-family: MathJax_Math-italic;">ϕ</span><span class="mo" id="MathJax-Span-173" style="font-family: MathJax_Main; padding-left: 0.246em;">∧</span><span class="mi" id="MathJax-Span-174" style="font-family: MathJax_Math-italic; padding-left: 0.246em;">ϕ</span><span class="mo" id="MathJax-Span-175" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-176" style="font-family: MathJax_Main; padding-left: 0.306em;">∣</span><span class="mo" id="MathJax-Span-177" style="font-family: MathJax_Main; padding-left: 0.306em;">(</span><span class="mi" id="MathJax-Span-178" style="font-family: MathJax_Math-italic;">ϕ</span><span class="mo" id="MathJax-Span-179" style="font-family: MathJax_Main; padding-left: 0.246em;">∨</span><span class="mi" id="MathJax-Span-180" style="font-family: MathJax_Math-italic; padding-left: 0.246em;">ϕ</span><span class="mo" id="MathJax-Span-181" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>ϕ</mi><mo>::=</mo><mi>p</mi><mo>∣</mo><mi mathvariant="normal">¬</mi><mi>p</mi><mo>∣</mo><mo stretchy="false">(</mo><mi>ϕ</mi><mo>∧</mo><mi>ϕ</mi><mo stretchy="false">)</mo><mo>∣</mo><mo stretchy="false">(</mo><mi>ϕ</mi><mo>∨</mo><mi>ϕ</mi><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-24">       
 \phi  ::=  p \mid \neg p \mid (\phi \land \phi) 
  \mid (\phi \lor \phi)
</script></span></p>
<p>No <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-25-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x2192;&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-182" role="math" style="width: 1.095em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.035em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.459em 1000.97em 2.309em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-183"><span class="mo" id="MathJax-Span-184" style="font-family: MathJax_Main;">→</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.691em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">→</mo></math></span></span><script type="math/tex" id="MathJax-Element-25">\rightarrow</script></span>, no <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-26-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x2194;&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-185" role="math" style="width: 1.095em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.035em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.459em 1000.97em 2.309em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-186"><span class="mo" id="MathJax-Span-187" style="font-family: MathJax_Main;">↔</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.691em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">↔</mo></math></span></span><script type="math/tex" id="MathJax-Element-26">\leftrightarrow</script></span> may occur, and negation signs are allowed only in front of proposition letters. The precondition of the following transformation is that the input formula is arrowfree. The transformation uses the equivalences between <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-27-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi&gt;&amp;#x03D5;&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-188" role="math" style="width: 2.005em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.945em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.277em 1001.95em 2.491em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-189"><span class="mi" id="MathJax-Span-190" style="font-family: MathJax_Main;">¬</span><span class="mi" id="MathJax-Span-191" style="font-family: MathJax_Main;">¬</span><span class="mi" id="MathJax-Span-192" style="font-family: MathJax_Math-italic;">ϕ</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 1.066em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">¬</mi><mi mathvariant="normal">¬</mi><mi>ϕ</mi></math></span></span><script type="math/tex" id="MathJax-Element-27">\neg \neg \phi</script></span> and <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-28-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;&amp;#x03D5;&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-193" role="math" style="width: 0.671em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.61em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.095em 1000.61em 2.309em -999.997em); top: -1.939em; left: 0.003em;"><span class="mrow" id="MathJax-Span-194"><span class="mi" id="MathJax-Span-195" style="font-family: MathJax_Math-italic;">ϕ</span></span><span style="display: inline-block; width: 0px; height: 1.945em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 1.066em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>ϕ</mi></math></span></span><script type="math/tex" id="MathJax-Element-28">\phi</script></span>, between <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-29-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;&amp;#x03D5;&lt;/mi&gt;&lt;mo&gt;&amp;#x2227;&lt;/mo&gt;&lt;mi&gt;&amp;#x03C8;&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-196" role="math" style="width: 4.008em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.887em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.217em 1003.77em 2.552em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-197"><span class="mi" id="MathJax-Span-198" style="font-family: MathJax_Main;">¬</span><span class="mo" id="MathJax-Span-199" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-200" style="font-family: MathJax_Math-italic;">ϕ</span><span class="mo" id="MathJax-Span-201" style="font-family: MathJax_Main; padding-left: 0.246em;">∧</span><span class="mi" id="MathJax-Span-202" style="font-family: MathJax_Math-italic; padding-left: 0.246em;">ψ</span><span class="mo" id="MathJax-Span-203" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>ϕ</mi><mo>∧</mo><mi>ψ</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-29">\neg (\phi \land \psi)</script></span> and <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-30-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi&gt;&amp;#x03D5;&lt;/mi&gt;&lt;mo&gt;&amp;#x2228;&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi&gt;&amp;#x03C8;&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-204" role="math" style="width: 3.887em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.765em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.277em 1003.77em 2.491em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-205"><span class="mi" id="MathJax-Span-206" style="font-family: MathJax_Main;">¬</span><span class="mi" id="MathJax-Span-207" style="font-family: MathJax_Math-italic;">ϕ</span><span class="mo" id="MathJax-Span-208" style="font-family: MathJax_Main; padding-left: 0.246em;">∨</span><span class="mi" id="MathJax-Span-209" style="font-family: MathJax_Main; padding-left: 0.246em;">¬</span><span class="mi" id="MathJax-Span-210" style="font-family: MathJax_Math-italic;">ψ</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 1.066em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">¬</mi><mi>ϕ</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>ψ</mi></math></span></span><script type="math/tex" id="MathJax-Element-30">\neg \phi \lor \neg \psi</script></span>, and between <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-31-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;&amp;#x03D5;&lt;/mi&gt;&lt;mo&gt;&amp;#x2228;&lt;/mo&gt;&lt;mi&gt;&amp;#x03C8;&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-211" role="math" style="width: 4.008em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.887em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.217em 1003.77em 2.552em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-212"><span class="mi" id="MathJax-Span-213" style="font-family: MathJax_Main;">¬</span><span class="mo" id="MathJax-Span-214" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-215" style="font-family: MathJax_Math-italic;">ϕ</span><span class="mo" id="MathJax-Span-216" style="font-family: MathJax_Main; padding-left: 0.246em;">∨</span><span class="mi" id="MathJax-Span-217" style="font-family: MathJax_Math-italic; padding-left: 0.246em;">ψ</span><span class="mo" id="MathJax-Span-218" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>ϕ</mi><mo>∨</mo><mi>ψ</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-31">\neg (\phi \lor \psi)</script></span> and <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-32-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi&gt;&amp;#x03D5;&lt;/mi&gt;&lt;mo&gt;&amp;#x2227;&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x00AC;&lt;/mi&gt;&lt;mi&gt;&amp;#x03C8;&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-219" role="math" style="width: 3.887em; display: inline-block;"><span style="display: inline-block; position: relative; width: 3.765em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.277em 1003.77em 2.491em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-220"><span class="mi" id="MathJax-Span-221" style="font-family: MathJax_Main;">¬</span><span class="mi" id="MathJax-Span-222" style="font-family: MathJax_Math-italic;">ϕ</span><span class="mo" id="MathJax-Span-223" style="font-family: MathJax_Main; padding-left: 0.246em;">∧</span><span class="mi" id="MathJax-Span-224" style="font-family: MathJax_Main; padding-left: 0.246em;">¬</span><span class="mi" id="MathJax-Span-225" style="font-family: MathJax_Math-italic;">ψ</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 1.066em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">¬</mi><mi>ϕ</mi><mo>∧</mo><mi mathvariant="normal">¬</mi><mi>ψ</mi></math></span></span><script type="math/tex" id="MathJax-Element-32">\neg \phi \land \neg \psi</script></span>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; nnf ::</span> <span class="dt">Form</span> <span class="ot">-&gt;</span> <span class="dt">Form</span> 
<span class="ot">&gt;</span> nnf (<span class="dt">Prop</span> x) <span class="fu">=</span> <span class="dt">Prop</span> x
<span class="ot">&gt;</span> nnf (<span class="dt">Neg</span> (<span class="dt">Prop</span> x)) <span class="fu">=</span> <span class="dt">Neg</span> (<span class="dt">Prop</span> x)
<span class="ot">&gt;</span> nnf (<span class="dt">Neg</span> (<span class="dt">Neg</span> f)) <span class="fu">=</span> nnf f
<span class="ot">&gt;</span> nnf (<span class="dt">Cnj</span> fs) <span class="fu">=</span> <span class="dt">Cnj</span> (map nnf fs)
<span class="ot">&gt;</span> nnf (<span class="dt">Dsj</span> fs) <span class="fu">=</span> <span class="dt">Dsj</span> (map nnf fs)
<span class="ot">&gt;</span> nnf (<span class="dt">Neg</span> (<span class="dt">Cnj</span> fs)) <span class="fu">=</span> <span class="dt">Dsj</span> (map (nnf<span class="fu">.</span><span class="dt">Neg</span>) fs)
<span class="ot">&gt;</span> nnf (<span class="dt">Neg</span> (<span class="dt">Dsj</span> fs)) <span class="fu">=</span> <span class="dt">Cnj</span> (map (nnf<span class="fu">.</span><span class="dt">Neg</span>) fs)</code></pre></div>
<p><strong>Review question</strong> What are the pre- and postconditions of <code>nnf</code>?</p>
<p><strong>Review question</strong> What are the pre- and postconditions of <code>nnf.arrowfree</code>?</p>
<hr>
<p>If there is time we will give a short introduction to <a href="http://homepages.cwi.nl/~jve/courses/15/fsa/fridays/ToyQuickCheck.html">QuickCheck</a>.</p>
<hr>
<p>Part of your lab work for this week consists of completing the CNF conversion process with further steps, and to test the results.</p>
<p>The workshop of today will help you to get more familiar with the language and semantics of propositional logic.</p>
<div id="references" class="references">

</div>


<div style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px; margin: 0px;"><div id="MathJax_Font_Test" style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; padding: 0px; border: 0px; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: normal; font-family: MathJax_AMS, sans-serif;"></div></div></body></html>