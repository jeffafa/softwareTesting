<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0070)http://homepages.cwi.nl/~jve/courses/15/testing/lectures/Lecture4.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="Content-Style-Type" content="text/css">
  <meta name="generator" content="pandoc">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="./Lecture4_files/buttondown.css" type="text/css">
  <script src="./Lecture4_files/MathJax.js" type="text/javascript"></script>
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><style type="text/css">.MathJax_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}
.MathJax .merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MathJax .MJX-monospace {font-family: monospace}
.MathJax .MJX-sans-serif {font-family: sans-serif}
#MathJax_Tooltip {background-color: InfoBackground; color: InfoText; border: 1px solid black; box-shadow: 2px 2px 5px #AAAAAA; -webkit-box-shadow: 2px 2px 5px #AAAAAA; -moz-box-shadow: 2px 2px 5px #AAAAAA; -khtml-box-shadow: 2px 2px 5px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true'); padding: 3px 4px; z-index: 401; position: absolute; left: 0; top: 0; width: auto; height: auto; display: none}
.MathJax {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}
.MathJax:focus, body :focus .MathJax {display: inline-table}
.MathJax img, .MathJax nobr, .MathJax a {border: 0; padding: 0; margin: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; vertical-align: 0; line-height: normal; text-decoration: none}
img.MathJax_strut {border: 0!important; padding: 0!important; margin: 0!important; vertical-align: 0!important}
.MathJax span {display: inline; position: static; border: 0; padding: 0; margin: 0; vertical-align: 0; line-height: normal; text-decoration: none}
.MathJax nobr {white-space: nowrap!important}
.MathJax img {display: inline!important; float: none!important}
.MathJax * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}
.MathJax_Processing {visibility: hidden; position: fixed; width: 0; height: 0; overflow: hidden}
.MathJax_Processed {display: none!important}
.MathJax_ExBox {display: block!important; overflow: hidden; width: 1px; height: 60ex; min-height: 0; max-height: none}
.MathJax .MathJax_EmBox {display: block!important; overflow: hidden; width: 1px; height: 60em; min-height: 0; max-height: none}
.MathJax .MathJax_HitBox {cursor: text; background: white; opacity: 0; filter: alpha(opacity=0)}
.MathJax .MathJax_HitBox * {filter: none; opacity: 1; background: transparent}
#MathJax_Tooltip * {filter: none; opacity: 1; background: transparent}
@font-face {font-family: MathJax_Main; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Main-bold; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Main-italic; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Math-italic; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Caligraphic; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Size1; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Size2; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Size3; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf?rev=2.6.0') format('opentype')}
@font-face {font-family: MathJax_Size4; src: url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff?rev=2.6.0') format('woff'), url('https://cdn.mathjax.org/mathjax/2.6-latest/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf?rev=2.6.0') format('opentype')}
.MathJax .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body><div style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="display: none;"></div>
<h1 id="lecture-4-functional-programming-and-imperative-programming">Lecture 4: Functional Programming and Imperative Programming</h1>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Lecture4</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">where</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.List</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Char</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Test.QuickCheck</span></code></pre></div>
<p>Recall from last time:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; update ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a,b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> update f (x,y) <span class="fu">=</span> \ z <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="fu">==</span> z <span class="kw">then</span> y <span class="kw">else</span> f z </code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; updates ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [(a,b)] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> updates <span class="fu">=</span> foldl update</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">infixl</span> <span class="dv">1</span> <span class="fu">$$</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; ($$) ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> (<span class="fu">$$</span>) <span class="fu">=</span> flip (<span class="fu">$</span>)</code></pre></div>
<p>We can use this to implement <em>variable assignment</em>, the basic action in imperative programming.</p>
<p>Define a <em>variable environment</em> (the representation of the computer memory) as a function from variables to appropriate values, let us say integers.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Var</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Var</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></code></pre></div>
<p>To implement variable assignment we need a datatype for expressions, for the assign command assigns an expression to a variable.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">I</span> <span class="dt">Integer</span> <span class="fu">|</span> <span class="dt">V</span> <span class="dt">Var</span> 
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span> 
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Subtr</span> <span class="dt">Expr</span> <span class="dt">Expr</span> 
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Mult</span> <span class="dt">Expr</span> <span class="dt">Expr</span> 
<span class="ot">&gt;</span>           <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</code></pre></div>
<p><strong>Evaluation of an expression in an environment</strong></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> 
<span class="ot">&gt;</span> eval _ (<span class="dt">I</span> i) <span class="fu">=</span> i 
<span class="ot">&gt;</span> eval c (<span class="dt">V</span> name) <span class="fu">=</span> c name
<span class="ot">&gt;</span> eval c (<span class="dt">Add</span> e1 e2)   <span class="fu">=</span> (eval c e1) <span class="fu">+</span> (eval c e2)
<span class="ot">&gt;</span> eval c (<span class="dt">Subtr</span> e1 e2) <span class="fu">=</span> (eval c e1) <span class="fu">-</span> (eval c e2)
<span class="ot">&gt;</span> eval c (<span class="dt">Mult</span> e1 e2)  <span class="fu">=</span> (eval c e1) <span class="fu">*</span> (eval c e2)</code></pre></div>
<p><strong>Variable Assignment in an Environment</strong></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; assign ::</span> <span class="dt">Var</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> 
<span class="ot">&gt;</span> assign var expr c <span class="fu">=</span> <span class="kw">let</span> 
<span class="ot">&gt;</span>    value <span class="fu">=</span> eval c expr 
<span class="ot">&gt;</span>  <span class="kw">in</span> 
<span class="ot">&gt;</span>    update c (var,value)</code></pre></div>
<p><strong>Environment initialisation</strong></p>
<p>An environment is a finite object, so it will yield <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x22A5;&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-1" role="math" style="width: 0.853em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.792em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.277em 1000.73em 2.309em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Main;">⊥</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.816em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">⊥</mi></math></span></span><script type="math/tex" id="MathJax-Element-1">\bot</script></span> (undefined) for all but a finite number of variables.</p>
<p>The initial environment is everywhere undefined:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; initEnv ::</span> <span class="dt">Env</span> 
<span class="ot">&gt;</span> initEnv <span class="fu">=</span> \ _ <span class="ot">-&gt;</span> undefined</code></pre></div>
<p><strong>The Four Ingredients of Imperative Programming</strong></p>
<ol style="list-style-type: decimal">
<li><p>Variable Assignment: <code>&lt;var&gt; := &lt;expr&gt;</code></p></li>
<li><p>Conditional Execution: <code>if &lt;bexpr&gt; then &lt;statement1&gt; else &lt;statement2&gt;</code></p></li>
<li><p>Sequential Composition: <code>&lt;statement1&gt; ; &lt;statement2&gt;</code></p></li>
<li><p>Iteration: <code>while &lt;expr&gt; do &lt;statement&gt;</code></p></li>
</ol>
<p>These four ingredients make for a <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a> programming language. A programming language is <em>Turing complete</em> if it is powerful enough to simulate a single taped <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing machine</a>.</p>
<p>It is believed that such languages can express any function that can be computed by an algorithm. This article of faith is called the <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church-Turing thesis</a>.</p>
<p><strong>Review Question</strong> Why is it impossible to <em>prove</em> the Church-Turing Thesis?</p>
<p><strong>Implementation of While Language in Haskell</strong></p>
<p>Conditions:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Condition</span> <span class="fu">=</span> <span class="dt">Prp</span> <span class="dt">Var</span> 
<span class="ot">&gt;</span>                <span class="fu">|</span> <span class="dt">Eq</span> <span class="dt">Expr</span> <span class="dt">Expr</span> 
<span class="ot">&gt;</span>                <span class="fu">|</span> <span class="dt">Lt</span> <span class="dt">Expr</span> <span class="dt">Expr</span> 
<span class="ot">&gt;</span>                <span class="fu">|</span> <span class="dt">Gt</span> <span class="dt">Expr</span> <span class="dt">Expr</span> 
<span class="ot">&gt;</span>                <span class="fu">|</span> <span class="dt">Ng</span> <span class="dt">Condition</span> 
<span class="ot">&gt;</span>                <span class="fu">|</span> <span class="dt">Cj</span> [<span class="dt">Condition</span>] 
<span class="ot">&gt;</span>                <span class="fu">|</span> <span class="dt">Dj</span> [<span class="dt">Condition</span>]
<span class="ot">&gt;</span>                <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</code></pre></div>
<p>Statements:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Statement</span> <span class="fu">=</span> <span class="dt">Ass</span> <span class="dt">Var</span> <span class="dt">Expr</span>
<span class="ot">&gt;</span>                <span class="fu">|</span> <span class="dt">Cond</span> <span class="dt">Condition</span> <span class="dt">Statement</span> <span class="dt">Statement</span>
<span class="ot">&gt;</span>                <span class="fu">|</span> <span class="dt">Seq</span> [<span class="dt">Statement</span>]
<span class="ot">&gt;</span>                <span class="fu">|</span> <span class="dt">While</span> <span class="dt">Condition</span> <span class="dt">Statement</span>
<span class="ot">&gt;</span>                <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</code></pre></div>
<p><strong>Condition Evaluation</strong></p>
<p>We will interpret basic conditions of the form <code>Prp v</code> by a check whether the value of <code>v</code> is non-zero.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; evalc ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Condition</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> evalc env (<span class="dt">Prp</span> v)    <span class="fu">=</span> env v <span class="fu">/=</span> <span class="dv">0</span>
<span class="ot">&gt;</span> evalc env (<span class="dt">Eq</span> e1 e2) <span class="fu">=</span> eval env e1 <span class="fu">==</span> eval env e2
<span class="ot">&gt;</span> evalc env (<span class="dt">Lt</span> e1 e2) <span class="fu">=</span> eval env e1 <span class="fu">&lt;</span>  eval env e2
<span class="ot">&gt;</span> evalc env (<span class="dt">Gt</span> e1 e2) <span class="fu">=</span> eval env e1 <span class="fu">&gt;</span>  eval env e2
<span class="ot">&gt;</span> evalc env (<span class="dt">Ng</span> c) <span class="fu">=</span> not (evalc env c)
<span class="ot">&gt;</span> evalc env (<span class="dt">Cj</span> cs) <span class="fu">=</span> and (map (evalc env) cs)
<span class="ot">&gt;</span> evalc env (<span class="dt">Dj</span> cs) <span class="fu">=</span> or  (map (evalc env) cs)</code></pre></div>
<p><strong>Statement Execution</strong></p>
<p>Executing a statement of the While language should be an operation that maps environments to environments.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; exec ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Statement</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> 
<span class="ot">&gt;</span> exec env (<span class="dt">Ass</span> v e) <span class="fu">=</span> assign v e env
<span class="ot">&gt;</span> exec env (<span class="dt">Cond</span> c s1 s2) <span class="fu">=</span> 
<span class="ot">&gt;</span>  <span class="kw">if</span> evalc env c <span class="kw">then</span> exec env s1 <span class="kw">else</span> exec env s2 
<span class="ot">&gt;</span> exec env (<span class="dt">Seq</span> ss) <span class="fu">=</span> foldl exec env ss                    
<span class="ot">&gt;</span> exec env w<span class="fu">@</span>(<span class="dt">While</span> c s) <span class="fu">=</span> 
<span class="ot">&gt;</span>  <span class="kw">if</span> not (evalc env c) <span class="kw">then</span> env 
<span class="ot">&gt;</span>  <span class="kw">else</span> exec (exec env s) w</code></pre></div>
<p><strong>Example</strong></p>
<p>Imperative program for computing the Fibonacci numbers:</p>
<pre><code>fib n
x := 0; y := 1; 
while n &gt; 0 do { z := x; x := y; y := z+y; n := n-1 }</code></pre>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fib ::</span> <span class="dt">Statement</span>
<span class="ot">&gt;</span> fib <span class="fu">=</span> <span class="dt">Seq</span> [<span class="dt">Ass</span> <span class="st">"x"</span> (<span class="dt">I</span> <span class="dv">0</span>), <span class="dt">Ass</span> <span class="st">"y"</span> (<span class="dt">I</span> <span class="dv">1</span>), 
<span class="ot">&gt;</span>            <span class="dt">While</span> (<span class="dt">Gt</span> (<span class="dt">V</span> <span class="st">"n"</span>) (<span class="dt">I</span> <span class="dv">0</span>))
<span class="ot">&gt;</span>              (<span class="dt">Seq</span> [<span class="dt">Ass</span> <span class="st">"z"</span> (<span class="dt">V</span> <span class="st">"x"</span>), 
<span class="ot">&gt;</span>                    <span class="dt">Ass</span> <span class="st">"x"</span> (<span class="dt">V</span> <span class="st">"y"</span>),
<span class="ot">&gt;</span>                    <span class="dt">Ass</span> <span class="st">"y"</span> (<span class="dt">Add</span> (<span class="dt">V</span> <span class="st">"z"</span>) (<span class="dt">V</span> <span class="st">"y"</span>)), 
<span class="ot">&gt;</span>                    <span class="dt">Ass</span> <span class="st">"n"</span> (<span class="dt">Subtr</span> (<span class="dt">V</span> <span class="st">"n"</span>) (<span class="dt">I</span> <span class="dv">1</span>))])]</code></pre></div>
<p>To <em>run</em> such programs, we initialize some variables to create an <em>environment</em>, execute a <em>statement</em>, and finally inspect, in the result environment, a list of variables that we are interested in.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; run ::</span> [(<span class="dt">Var</span>,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Statement</span> <span class="ot">-&gt;</span> [<span class="dt">Var</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
<span class="ot">&gt;</span> run xs program vars <span class="fu">=</span> 
<span class="ot">&gt;</span>   exec (updates initEnv xs) program <span class="fu">$$</span> 
<span class="ot">&gt;</span>     \ env <span class="ot">-&gt;</span> map (eval env) (map <span class="dt">V</span> vars)</code></pre></div>
<p>Now we can run <code>fib</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> runFib n <span class="fu">=</span> run [(<span class="st">"n"</span>,n)] fib [<span class="st">"x"</span>]</code></pre></div>
<p><strong>Comparison with Functional Version</strong></p>
<p>Here is the definition of <code>while</code> again:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; while ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> while <span class="fu">=</span> until <span class="fu">.</span> (not<span class="fu">.</span>)</code></pre></div>
<p><strong>While + Return</strong></p>
<p>Sometimes it is useful to include a function for transforming the result:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; whiler ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> whiler p f r <span class="fu">=</span> r <span class="fu">.</span> while p f </code></pre></div>
<p>Now we can do <em>fib</em> in <em>functional imperative style</em>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fibonacci ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> fibonacci n <span class="fu">=</span> fibon (<span class="dv">0</span>,<span class="dv">1</span>,n) <span class="kw">where</span> 
<span class="ot">&gt;</span>   fibon <span class="fu">=</span> whiler 
<span class="ot">&gt;</span>            (\ (_,_,n) <span class="ot">-&gt;</span> n <span class="fu">&gt;</span> <span class="dv">0</span>)
<span class="ot">&gt;</span>            (\ (x,y,n) <span class="ot">-&gt;</span> (y,x<span class="fu">+</span>y,n<span class="fu">-</span><span class="dv">1</span>))
<span class="ot">&gt;</span>            (\ (x,_,_) <span class="ot">-&gt;</span> x)</code></pre></div>
<hr>
<p>The key to showing the correctness of the imperative version of the Fibonacci algorithm is to show that <code>(x,y) = (F(N-n),F(N-n+1))</code> holds for the step inside the <code>while</code> loop, where N is the initial value of variable <code>n</code>.</p>
<p>In other words, suppose <code>(x,y) = (F(N-n),F(N-n+1))</code>, and execute the statement <code>(x,y,n) := (y,x+y,n-1)</code>. Then afterwards, <code>(x,y) = (F(N-n),F(N-n+1))</code> holds again.</p>
<p>The functional programmer, instead of checking a loop invariant, proves with induction on <code>k</code> that after the call <code>fb n</code>, <code>fb'</code> is always called with parameters <code>F(n-k), F(n-k+1), k</code>.</p>
<p>We see that proving the loop invariant corresponds to proving the inductive step in the induction proof. In the imperative version we have to deal with three variables <code>x,y,n</code> and in the recursive functional version we reason about three function arguments.</p>
<hr>
<p><strong>While Loops as Fixpoints</strong></p>
<p>The definition of a fixpoint operation.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fp ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a 
<span class="ot">&gt;</span> fp f <span class="fu">=</span> until (\ x <span class="ot">-&gt;</span> x <span class="fu">==</span> f x) f</code></pre></div>
<p>Using this, we can construct another variation on Fibonacci:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> fbo n <span class="fu">=</span> (<span class="dv">0</span>,<span class="dv">1</span>,n) <span class="fu">$$</span> 
<span class="ot">&gt;</span>          fp (\ (x,y,k) <span class="ot">-&gt;</span> <span class="kw">if</span> k <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> (x,y,k) <span class="kw">else</span> (y,x<span class="fu">+</span>y,k<span class="fu">-</span><span class="dv">1</span>))</code></pre></div>
<p><strong>Aside: Fixpoint Calculation of Square Roots</strong></p>
<p><a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method">The Babylonian method</a> of computing square roots: repeatedly take the average of an overestimation <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-4" role="math" style="width: 0.671em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.61em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.338em 1000.55em 2.127em -999.997em); top: -1.939em; left: 0.003em;"><span class="mrow" id="MathJax-Span-5"><span class="mi" id="MathJax-Span-6" style="font-family: MathJax_Math-italic;">x</span></span><span style="display: inline-block; width: 0px; height: 1.945em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 0.566em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-2">x</script></span> and an underestimation <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-7" role="math" style="width: 1.702em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.641em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(1.217em 1001.58em 2.552em -999.997em); top: -2.121em; left: 0.003em;"><span class="mrow" id="MathJax-Span-8"><span class="mi" id="MathJax-Span-9" style="font-family: MathJax_Math-italic;">a</span><span class="texatom" id="MathJax-Span-10"><span class="mrow" id="MathJax-Span-11"><span class="mo" id="MathJax-Span-12" style="font-family: MathJax_Main;">/</span></span></span><span class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math-italic;">x</span></span><span style="display: inline-block; width: 0px; height: 2.127em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-3">a/x</script></span> to <span class="math inline"><span class="MathJax_Preview" style="color: inherit;"></span><span class="MathJax" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msqrt&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msqrt&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-14" role="math" style="width: 1.459em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.399em; height: 0px; font-size: 103%;"><span style="position: absolute; clip: rect(0.064em 1001.4em 1.459em -999.997em); top: -0.968em; left: 0.003em;"><span class="mrow" id="MathJax-Span-15"><span class="msqrt" id="MathJax-Span-16"><span style="display: inline-block; position: relative; width: 1.338em; height: 0px;"><span style="position: absolute; clip: rect(3.401em 1000.49em 4.19em -999.997em); top: -4.002em; left: 0.853em;"><span class="mrow" id="MathJax-Span-17"><span class="mi" id="MathJax-Span-18" style="font-family: MathJax_Math-italic;">a</span></span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span><span style="position: absolute; clip: rect(0.913em 1000.55em 1.338em -999.997em); top: -1.817em; left: 0.853em;"><span style="display: inline-block; overflow: hidden; vertical-align: -0.058em; border-top-width: 1.3px; border-top-style: solid; width: 0.549em; height: 0px;"></span><span style="display: inline-block; width: 0px; height: 1.095em;"></span></span><span style="position: absolute; clip: rect(3.037em 1000.85em 4.372em -999.997em); top: -3.941em; left: 0.003em;"><span style="font-family: MathJax_Main;">√</span><span style="display: inline-block; width: 0px; height: 4.008em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 0.974em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left-width: 0px; border-left-style: solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mi>a</mi></msqrt></math></span></span><script type="math/tex" id="MathJax-Element-4">\sqrt{a}</script></span>.</p>
<p>This works well in Haskell because of the limited precision of floating point numbers.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> bab a <span class="fu">=</span> \ x <span class="ot">-&gt;</span> ((x <span class="fu">+</span> a<span class="fu">/</span>x)<span class="fu">/</span><span class="dv">2</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> sr a <span class="fu">=</span> fp (bab a) a</code></pre></div>
<p>This gives:</p>
<pre><code> *Lecture4&gt; sr 2
 1.414213562373095
 *Lecture4&gt; sr 3
 1.7320508075688772
 *Lecture4&gt; sr 4
 2.0
 *Lecture4&gt; sr 5
 2.23606797749979</code></pre>
<p><strong>Review question</strong> How can you <em>test</em> this square root program?</p>
<p>To see a bit clearer what goes on here, use the following function:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; iterateFix ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> iterateFix f <span class="fu">=</span> apprx <span class="fu">.</span> iterate f <span class="kw">where</span>
<span class="ot">&gt;</span>   apprx (x<span class="fu">:</span>y<span class="fu">:</span>zs) <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">==</span> y <span class="kw">then</span> [x] <span class="kw">else</span> x<span class="fu">:</span> apprx (y<span class="fu">:</span>zs)</code></pre></div>
<pre><code> *Lecture4&gt; iterateFix (bab 2) 1
 [1.0,1.5,1.4166666666666665,1.4142156862745097,1.4142135623746899,1.414213562373095]
 *Lecture4&gt; iterateFix (bab 3) 1
 [1.0,2.0,1.75,1.7321428571428572,1.7320508100147274,1.7320508075688772]
 *Lecture4&gt; iterateFix (bab 4) 1
 [1.0,2.5,2.05,2.000609756097561,2.0000000929222947,2.000000000000002,2.0]</code></pre>
<p><strong>Fix</strong></p>
<p>Haskell has a special fixpoint operator that can be used to implement recursion.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fix ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> fix f <span class="fu">=</span> f (fix f)</code></pre></div>
<p>Alternative definition:</p>
<pre><code>fix f = let x = f x in x</code></pre>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> fbx n <span class="fu">=</span> (<span class="dv">0</span>,<span class="dv">1</span>,n) <span class="fu">$$</span> 
<span class="ot">&gt;</span>          fix (\ f (x,y,k) <span class="ot">-&gt;</span> <span class="kw">if</span> k <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> x <span class="kw">else</span> f (y,x<span class="fu">+</span>y,k<span class="fu">-</span><span class="dv">1</span>))</code></pre></div>
<p>Without using <code>fix</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> fbb n <span class="fu">=</span> fbbb (<span class="dv">0</span>,<span class="dv">1</span>,n) <span class="kw">where</span> 
<span class="ot">&gt;</span>   fbbb (x,y,n) <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> x <span class="kw">else</span> fbbb (y,x<span class="fu">+</span>y,n<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
<p>Or in curried notation:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> fbc n <span class="fu">=</span> fbbc <span class="dv">0</span> <span class="dv">1</span> n <span class="kw">where</span> 
<span class="ot">&gt;</span>   fbbc x y n <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> x <span class="kw">else</span> fbbc y (x<span class="fu">+</span>y) (n<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
<p><strong>Fix</strong> can be used to implement recursion without using other functions that call themselves.</p>
<p>To see why this works, notice that <code>fbx</code> will compute a fixed point of the function</p>
<pre><code>  k = (\ f (x,y,k) -&gt;
        if k == 0 then (x,y,k) else f (y,x+y,k-1))</code></pre>
<p>that is, a function <code>h</code> such that <code>h = k  h</code>:</p>
<pre><code>  h = k h =
     (\ f (x,y,k) -&gt;
        if k == 0 then (x,y,k) else f (y,x+y,k-1)) h
    = \ (x,y,k) -&gt;
        if k == 0 then (x,y,k) else h (y,x+y,k-1))</code></pre>
<p>This is indeed the recursive Fibonacci function.</p>
<p><strong>Review question</strong></p>
<p>Explain the difference between <code>fp</code> and <code>fix</code>.</p>
<hr>
<p>To see a connection between <code>fp</code> and <code>fix</code>, consider the following definition of <code>fp</code> in terms of <code>fix</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fp' ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> fp' f <span class="fu">=</span> fix 
<span class="ot">&gt;</span>          (\ g x <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="fu">==</span> f x <span class="kw">then</span> x <span class="kw">else</span> g (f x))</code></pre></div>
<p>And here are definitions of <code>until</code> and <code>while</code> in terms of <code>fix</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; until' ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> until' p f <span class="fu">=</span> fix 
<span class="ot">&gt;</span>               (\ g x <span class="ot">-&gt;</span> <span class="kw">if</span> p x <span class="kw">then</span> x <span class="kw">else</span> g (f x))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; while' ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> while' p f <span class="fu">=</span> fix 
<span class="ot">&gt;</span>               (\ g x <span class="ot">-&gt;</span> <span class="kw">if</span> not (p x) <span class="kw">then</span> x <span class="kw">else</span> g (f x))</code></pre></div>
<hr>
<h1 id="lets-talk-about-quickcheck">Let's Talk about QuickCheck</h1>
<p><a href="http://en.wikipedia.org/wiki/QuickCheck">QuickCheck</a> is a very influential random test generation approach to testing.</p>
<p>"In QuickCheck the programmer writes assertions about logical properties that a function should fulfill. Then QuickCheck attempts to generate test cases that falsify these assertions. The project was started in 1999. Besides being used to test regular programs, QuickCheck is also useful for building up a functional specification, for documenting what functions should be doing, and for testing compiler implementations."</p>
<p>The latest version of the code can be found at <a href="https://github.com/nick8325/quickcheck">github</a>. There is a (slightly outdated) <a href="http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html">QuickCheck Manual</a>. The original paper on QuickCheck is <span class="citation">(Claessen and Hughes 2000)</span>. This is recommended reading.</p>
<h1 id="quickcheck-example-the-pebble-game">QuickCheck Example: The Pebble Game</h1>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Color</span> <span class="fu">=</span> <span class="dt">W</span> <span class="fu">|</span> <span class="dt">B</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; drawPebble ::</span> [<span class="dt">Color</span>] <span class="ot">-&gt;</span> [<span class="dt">Color</span>]
<span class="ot">&gt;</span> drawPebble [] <span class="fu">=</span> []
<span class="ot">&gt;</span> drawPebble [x] <span class="fu">=</span> [x]
<span class="ot">&gt;</span> drawPebble (<span class="dt">W</span><span class="fu">:</span><span class="dt">W</span><span class="fu">:</span>xs) <span class="fu">=</span> drawPebble (<span class="dt">B</span><span class="fu">:</span>xs) 
<span class="ot">&gt;</span> drawPebble (<span class="dt">B</span><span class="fu">:</span><span class="dt">B</span><span class="fu">:</span>xs) <span class="fu">=</span> drawPebble (<span class="dt">B</span><span class="fu">:</span>xs) 
<span class="ot">&gt;</span> drawPebble (<span class="dt">W</span><span class="fu">:</span><span class="dt">B</span><span class="fu">:</span>xs) <span class="fu">=</span> drawPebble (<span class="dt">W</span><span class="fu">:</span>xs) 
<span class="ot">&gt;</span> drawPebble (<span class="dt">B</span><span class="fu">:</span><span class="dt">W</span><span class="fu">:</span>xs) <span class="fu">=</span> drawPebble (<span class="dt">W</span><span class="fu">:</span>xs) </code></pre></div>
<p><strong>What is the colour of the last pebble?</strong></p>
<pre><code> *Lecture4&gt; drawPebble [W,W,B,B]
 [B]
 *Lecture4&gt; drawPebble [W,W,B,B,W,W,W]
 [W]
 *Lecture4&gt; drawPebble [W,W,B,B,W,W,W,B,W,B,B]
 [B]
 *Lecture4&gt; drawPebble [W,W,B,B,W,W,W,B,W,B,B,W]
 [W]
 *Lecture4&gt; drawPebble [W,W,B,B,W,W,W,B,W,B,B,W,W,W,W]
 [B]</code></pre>
<p><strong>Test Generators</strong></p>
<pre><code> newtype Gen a = MkGen{ unGen :: StdGen -&gt; Int -&gt; a }
 
 instance Functor Gen where
   fmap f (MkGen h) =
     MkGen (\r n -&gt; f (h r n))
 
 instance Monad Gen where
   return x =
     MkGen (\_ _ -&gt; x)
   
   MkGen m &gt;&gt;= k =
     MkGen (\r n -&gt;
       let (r1,r2)  = split r
           MkGen m' = k (m r1 n)
        in m' r2 n
     )</code></pre>
<p><strong>RandomGen, next, split</strong></p>
<p>The class <code>RandomGen</code>, defined in <code>System.Random</code>, provides a common interface to random number generators.</p>
<p>Minimal complete definition: <code>next</code> and <code>split</code>.</p>
<pre><code> next :: g -&gt; (Int, g)</code></pre>
<p>The <code>next</code> operation returns an <code>Int</code> that is uniformly distributed in the range returned by <code>genRange</code> (including both end points), and a new generator.</p>
<pre><code> split :: g -&gt; (g, g)</code></pre>
<p>The <code>split</code> operation allows one to obtain two distinct random number generators. This is very useful in functional programs (for example, when passing a random number generator down to recursive calls).</p>
<p><strong>StdGen</strong></p>
<p>Instance of <code>RandomGen</code>.</p>
<p>Defined in <code>System.Random</code> module.</p>
<p><strong>choose</strong></p>
<p>Defined in <code>QuickCheck</code> module.</p>
<p>Generates a random element in the given inclusive range.</p>
<pre><code> choose :: Random a =&gt; (a,a) -&gt; Gen a
 choose rng = MkGen (\r _ -&gt; 
              let (x,_) = randomR rng r in x)</code></pre>
<p><strong>Random a</strong></p>
<p>Defined in <code>QuickCheck</code> module.</p>
<p>With a source of random number supply in hand, the <code>Random</code> class allows the programmer to extract random values of a variety of types.</p>
<p>Minimal complete definition: <code>randomR</code> and <code>random</code>.</p>
<pre><code> randomR :: RandomGen g =&gt; (a, a) -&gt; g -&gt; (a, g)</code></pre>
<p>Takes a range <code>(lo,hi)</code> and a random number generator <code>g</code>, and returns a random value uniformly distributed in the closed interval <code>[lo,hi]</code>, together with a new generator. It is unspecified what happens if <code>lo&gt;hi</code>. For continuous types there is no requirement that the values <code>lo</code> and <code>hi</code> are ever produced, but they may be, depending on the implementation and the interval.</p>
<pre><code> random :: RandomGen g =&gt; g -&gt; (a, g)</code></pre>
<p>The same as <code>randomR</code>, but using a default range determined by the type:</p>
<ul>
<li><p>For bounded types (instances of Bounded, such as Char), the range is normally the whole type.</p></li>
<li><p>For fractional types, the range is normally the semi-closed interval <code>[0,1)</code>.</p></li>
<li><p>For Integer, the range is (arbitrarily) the range of <code>Int</code>.</p></li>
</ul>
<p><strong>Class Arbitrary</strong></p>
<p>Defined in <code>QuickCheck</code> module.</p>
<p>Random generation and shrinking of values.</p>
<pre><code> class Arbitrary a where
   -- | A generator for values of the given type.
   arbitrary :: Gen a
   arbitrary = error "no default generator"
   
   -- | Produces a (possibly) empty list of 
   -- all the possible
   -- immediate shrinks of the given value.
   shrink :: a -&gt; [a]
   shrink _ = []
 </code></pre>
<p><strong>Making Color an Instance of Arbitrary</strong></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Color</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   arbitrary <span class="fu">=</span> oneof [return <span class="dt">W</span>, return <span class="dt">B</span>]</code></pre></div>
<p>This allows QuickCheck to derive <code>Arbitrary [Color]</code> ...</p>
<p>Here is how:</p>
<pre><code> instance Arbitrary a =&gt; Arbitrary [a] where
   arbitrary = sized $ \n -&gt;
     do k &lt;- choose (0,n)
        sequence [ arbitrary | _ &lt;- [1..k] ]
 
   shrink xs = removeChunks xs ...</code></pre>
<p><strong>sample for generating example values</strong></p>
<pre><code> sample' :: Gen a -&gt; IO [a]
 sample' (MkGen m) =
   do rnd0 &lt;- newStdGen
      let rnds rnd = rnd1 : rnds rnd2 
                     where (rnd1,rnd2) = split rnd
      return [(m r n) | 
              (r,n) &lt;- rnds rnd0 `zip` [0,2..20] ]
 </code></pre>
<p>Generating some example values and print them to <code>stdout</code>:</p>
<pre><code> sample :: Show a =&gt; Gen a -&gt; IO ()
 sample g =
   do cases &lt;- sample' g
      sequence_ (map print cases)</code></pre>
<p><strong>Example Use</strong></p>
<pre><code> *Lecture4&gt; sample $ (arbitrary :: Gen [Color])
 []
 [W]
 [W,W]
 [W,B,W]
 [W,B,W,B]
 [B,B,B,W,B,W,W]
 [B,W,B,W,B,W,B,W,B,B,W]
 []
 [B,B,B,B,B,W,B,B,W,B,W,W,W,B]
 [W,W,B,B,W,W,B,W,B,B,B,B,W,W,B]
 [W,W,W,W,W,W,B,B,B,W,B,W,B,B]
 </code></pre>
<p><strong>Stating an Invariant</strong></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; numberW ::</span> [<span class="dt">Color</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> numberW <span class="fu">=</span> length <span class="fu">.</span> (filter (<span class="fu">==</span> <span class="dt">W</span>)) 
<span class="ot">&gt;</span>     
<span class="ot">&gt; parityW ::</span> [<span class="dt">Color</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> parityW xs <span class="fu">=</span>  mod (numberW xs) <span class="dv">2</span>
<span class="ot">&gt;</span>     
<span class="ot">&gt;</span> prop_invariant xs <span class="fu">=</span> 
<span class="ot">&gt;</span>   parityW xs <span class="fu">==</span> parityW (drawPebble xs)</code></pre></div>
<p><strong>Testing This ...</strong></p>
<pre><code> Lecture4&gt; quickCheck prop_invariant
 +++ OK, passed 100 tests.
  </code></pre>
<p>See what happens with an unreasonable property</p>
<p>Strange invariant:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> prop_length xs <span class="fu">=</span> length xs <span class="fu">==</span> length (drawPebble xs)</code></pre></div>
<pre><code> Lecture4&gt; quickCheck prop_length
 *** Failed! Falsifiable (after 7 tests and 1 shrink):     
 [B,B]
 *Lecture4&gt; quickCheck prop_length
 *** Failed! Falsifiable (after 6 tests and 1 shrink):     
 [B,W]
 *Lecture4&gt; quickCheck prop_length
 *** Failed! Falsifiable (after 3 tests):                  
 [B,B]
 </code></pre>
<hr>
<p>Workshop this week: <a href="http://homepages.cwi.nl/~jve/courses/15/testing/workshops/Workshop4.pdf">Workshop4.pdf</a>.</p>
<p>Lab work this week: <a href="http://homepages.cwi.nl/~jve/courses/15/testing/lab/Lab4.html">Lab4.html</a>.</p>
<p>Back to <a href="http://homepages.cwi.nl/~jve/courses/15/testing/index.html">main course page</a>.</p>
<hr>
<div id="references" class="references">
<div id="ref-ClaessenHughes2000:q">
<p>Claessen, Koen, and John Hughes. 2000. “QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs.” In <em>Proc. of International Conference on Functional Programming (ICFP)</em>. ACM SIGPLAN.</p>
</div>
</div>


<div style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px; margin: 0px;"><div id="MathJax_Font_Test" style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; padding: 0px; border: 0px; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: normal; font-family: MathJax_Math-italic, sans-serif;"></div></div></body></html>